<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>InnKeeper - Master Generation Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            color: #eee;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: #16213e;
            border-bottom: 2px solid #0f3460;
            padding: 15px 20px;
            color: #ffd700;
            text-align: center;
            flex-shrink: 0;
        }

        .header h1 {
            font-size: 1.8em;
            margin-bottom: 5px;
        }

        .header p {
            color: #aaa;
            font-size: 0.9em;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
            min-height: 0;
        }

        /* Tab Navigation */
        .tab-nav {
            background: #0f3460;
            border-bottom: 2px solid #16213e;
            display: flex;
            flex-shrink: 0;
            padding: 0 10px;
        }

        .tab-button {
            padding: 12px 20px;
            background: transparent;
            border: none;
            color: #aaa;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
        }

        .tab-button:hover {
            color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
        }

        .tab-button.active {
            color: #ffd700;
            border-bottom-color: #ffd700;
            background: rgba(255, 215, 0, 0.05);
        }

        /* Left Sidebar - Parameters */
        .left-sidebar {
            width: 320px;
            background: #16213e;
            border-right: 2px solid #0f3460;
            padding: 15px;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .left-sidebar h2 {
            color: #ffd700;
            margin-bottom: 15px;
            font-size: 1.2em;
            text-align: center;
        }

        .control-group {
            margin-bottom: 15px;
            padding: 10px;
            background: #0f3460;
            border-radius: 4px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: #ffd700;
            font-weight: bold;
            font-size: 0.9em;
        }

        input[type="text"],
        input[type="number"],
        select,
        textarea {
            width: 100%;
            padding: 6px 10px;
            background: #1a1a2e;
            border: 2px solid #0f3460;
            color: #eee;
            font-family: 'Courier New', monospace;
            border-radius: 4px;
            font-size: 0.9em;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #ffd700;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }

        input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
        }

        .slider-value {
            display: inline-block;
            min-width: 40px;
            text-align: right;
            color: #ffd700;
            font-weight: bold;
        }

        button {
            padding: 10px;
            background: #0f3460;
            border: 2px solid #ffd700;
            color: #ffd700;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.2s;
        }

        button:hover {
            background: #ffd700;
            color: #1a1a2e;
        }

        button:active {
            transform: scale(0.98);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .button-primary {
            width: 100%;
            padding: 12px;
            font-size: 1.1em;
            margin-top: 10px;
        }

        /* Main View Area */
        .main-view {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #0f1419;
            overflow: hidden;
        }

        .tab-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Shared Context Panel */
        .context-panel {
            width: 280px;
            background: #16213e;
            border-left: 2px solid #0f3460;
            padding: 15px;
            overflow-y: auto;
            flex-shrink: 0;
            font-size: 0.85em;
        }

        .context-panel h3 {
            color: #ffd700;
            margin-bottom: 10px;
            font-size: 1em;
        }

        .context-item {
            background: #0f3460;
            padding: 8px;
            margin-bottom: 8px;
            border-radius: 4px;
            font-size: 0.85em;
        }

        .context-item strong {
            color: #ffd700;
        }

        /* Results Display */
        .results-container {
            background: #16213e;
            border: 2px solid #0f3460;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 15px;
        }

        .entity-card,
        .item-card {
            background: #0f3460;
            border: 2px solid #16213e;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 15px;
        }

        .entity-name,
        .item-name {
            font-size: 1.5em;
            color: #ffd700;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .entity-type {
            color: #aaa;
            font-size: 0.9em;
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        .entity-description {
            color: #ccc;
            font-style: italic;
            line-height: 1.6;
            margin: 10px 0;
        }

        .entity-section {
            margin: 10px 0;
            padding: 8px;
            background: #1a1a2e;
            border-radius: 4px;
        }

        .entity-section-title {
            color: #ffd700;
            font-weight: bold;
            font-size: 1em;
            margin-bottom: 5px;
            border-bottom: 1px solid #0f3460;
            padding-bottom: 3px;
        }

        .entity-property {
            margin: 3px 0;
            padding: 3px;
            font-size: 0.9em;
        }

        .entity-property-label {
            color: #ffd700;
            font-weight: bold;
            display: inline-block;
            min-width: 120px;
        }

        .entity-property-value {
            color: #eee;
        }

        /* Map Grid */
        .map-grid-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
        }

        .map-grid {
            display: grid;
            gap: 2px;
            background: #0a0e14;
            padding: 10px;
            border: 2px solid #0f3460;
        }

        .map-cell {
            width: 20px;
            height: 20px;
            background: #1a2332;
            border: 1px solid #2a3441;
            cursor: pointer;
            transition: all 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
        }

        .map-cell:hover {
            border-color: #ffd700;
            transform: scale(1.3);
            z-index: 10;
        }

        .map-cell.selected {
            border: 2px solid #ffd700;
            box-shadow: 0 0 8px #ffd700;
        }

        .map-cell.has-geography { background: #2d5016; }
        .map-cell.has-organization { background: #4a2c5a; }
        .map-cell.has-dungeon { background: #5a1a1a; }
        .map-cell.has-landmark { background: #3d3d1a; }
        .map-cell.has-ruin { background: #2a2a1a; }
        .map-cell.has-trading { background: #2a3a2a; }

        /* Loading Indicator */
        .loading {
            text-align: center;
            padding: 40px;
            color: #ffd700;
            font-size: 1.2em;
            display: none;
        }

        .loading.active {
            display: block;
        }

        /* Tree View */
        .tree-view {
            background: #0f3460;
            padding: 15px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .tree-node {
            margin: 5px 0;
        }

        .tree-toggle {
            cursor: pointer;
            color: #ffd700;
            font-weight: bold;
            margin-right: 5px;
            user-select: none;
            display: inline-block;
            padding: 2px 5px;
        }
        
        .tree-toggle:hover {
            background-color: rgba(255, 215, 0, 0.1);
            border-radius: 3px;
        }

        .tree-children {
            margin-left: 20px;
            border-left: 1px solid #16213e;
            padding-left: 10px;
            display: none;
        }

        .tree-children.expanded {
            display: block;
        }

        /* JSON Display */
        .json-display {
            background: #0a0a0a;
            border: 1px solid #0f3460;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            color: #0f0;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 400px;
            overflow-y: auto;
        }

        /* Item Rarity Colors */
        .rarity-common { color: #9d9d9d; }
        .rarity-uncommon { color: #1eff00; }
        .rarity-rare { color: #0070dd; }
        .rarity-epic { color: #a335ee; }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        ::-webkit-scrollbar-track {
            background: #0f3460;
        }

        ::-webkit-scrollbar-thumb {
            background: #16213e;
            border-radius: 6px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #1a1a2e;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ΓÜö∩╕Å InnKeeper Master Generation Tool ΓÜö∩╕Å</h1>
        <p>Unified Interface for World, Map, Dungeon, and Item Generation Systems</p>
    </div>

    <div class="tab-nav">
        <button class="tab-button active" data-tab="world">World Generation</button>
        <button class="tab-button" data-tab="dungeon">Dungeon Registry</button>
        <button class="tab-button" data-tab="item">Item Generation</button>
        <button class="tab-button" data-tab="party">Party Generation</button>
        <button class="tab-button" data-tab="combat">Combat Simulation</button>
    </div>

    <div class="main-content">
        <!-- Left Sidebar - Parameters -->
        <div class="left-sidebar">
            <!-- World Generation Controls -->
            <div id="world-controls" class="tab-controls">
                <h2>World Generation</h2>
                <div class="control-group">
                    <label>World Seed</label>
                    <input type="text" id="world-seed" placeholder="Leave empty for random">
                    <button onclick="generateRandomSeed('world-seed')" style="margin-top: 5px; padding: 6px; font-size: 0.85em;">Random Seed</button>
                </div>
                <div class="control-group">
                    <label>Generation Levels</label>
                    <div class="checkbox-group">
                        <div class="checkbox-item"><input type="checkbox" id="level-1" checked> <label for="level-1">Level 1: Primordials</label></div>
                        <div class="checkbox-item"><input type="checkbox" id="level-2" checked> <label for="level-2">Level 2: Cosmic Creators</label></div>
                        <div class="checkbox-item"><input type="checkbox" id="level-2.5" checked> <label for="level-2.5">Level 2.5: Geography</label></div>
                        <div class="checkbox-item"><input type="checkbox" id="level-3" checked> <label for="level-3">Level 3: Conceptual Beings</label></div>
                        <div class="checkbox-item"><input type="checkbox" id="level-4" checked> <label for="level-4">Level 4: Demi-Gods</label></div>
                        <div class="checkbox-item"><input type="checkbox" id="level-5" checked> <label for="level-5">Level 5: Mortal Races</label></div>
                        <div class="checkbox-item"><input type="checkbox" id="level-6" checked> <label for="level-6">Level 6: Organizations</label></div>
                        <div class="checkbox-item"><input type="checkbox" id="level-6.5" checked> <label for="level-6.5">Level 6.5: Standout Mortals</label></div>
                        <div class="checkbox-item"><input type="checkbox" id="level-7.5" checked> <label for="level-7.5">Level 7.5: Dungeons</label></div>
                    </div>
                </div>
                <div class="control-group">
                    <label>Organization Density</label>
                    <select id="organization-density">
                        <option value="sparse">Sparse</option>
                        <option value="normal" selected>Normal</option>
                        <option value="dense">Dense</option>
                    </select>
                </div>
                <button class="button-primary" onclick="generateWorld()">Generate World</button>
                <button onclick="exportWorldContext()" style="width: 100%; margin-top: 5px; padding: 8px; font-size: 0.9em;">Export World Context</button>
            </div>

            <!-- Dungeon Registry Controls -->
            <div id="dungeon-controls" class="tab-controls" style="display: none;">
                <h2>Dungeon Registry</h2>
                <div style="background: #1a1a2e; padding: 15px; border-radius: 5px; margin-bottom: 15px; border: 1px solid #16213e;">
                    <p style="margin: 0; color: #aaa; line-height: 1.6;">
                        Dungeons are generated as part of world generation (Level 7.5). 
                        Each dungeon has provenance linking it to its creator (organization or standout mortal)
                        and exists at a specific geography location.
                    </p>
                </div>
                <div class="control-group">
                    <label>View Dungeon Registry</label>
                    <p style="color: #aaa; font-size: 0.9em; margin: 5px 0;">
                        Generate a world with Level 7.5 (Dungeons) enabled first, then view the dungeon registry here.
                    </p>
                    <button class="button-primary" onclick="viewDungeonRegistry()">View Dungeon Registry</button>
                </div>
            </div>

            <!-- Item Generation Controls -->
            <div id="item-controls" class="tab-controls" style="display: none;">
                <h2>Item Generation</h2>
                <div class="control-group">
                    <label>Number of Items</label>
                    <input type="number" id="item-count" min="1" max="100" value="10">
                </div>
                <div class="control-group">
                    <label>Generation Context</label>
                    <select id="item-context">
                        <option value="dungeon_loot">Dungeon Loot</option>
                        <option value="monster_drop">Monster Drop</option>
                        <option value="boss_drop">Boss Drop</option>
                        <option value="vendor">Vendor Stock</option>
                        <option value="quest_reward">Quest Reward</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Level</label>
                    <input type="range" id="item-level" min="1" max="20" value="5" oninput="document.getElementById('item-level-value').textContent = this.value">
                    <span class="slider-value" id="item-level-value">5</span>
                </div>
                <div class="control-group">
                    <label>Class Preference</label>
                    <select id="item-class">
                        <option value="any">Any</option>
                        <option value="warrior">Warrior</option>
                        <option value="mage">Mage</option>
                        <option value="rogue">Rogue</option>
                        <option value="cleric">Cleric</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Rarity Modifier</label>
                    <input type="range" id="rarity-modifier" min="0" max="200" value="100" oninput="document.getElementById('rarity-modifier-value').textContent = this.value + '%'">
                    <span class="slider-value" id="rarity-modifier-value">100%</span>
                </div>
                <div class="control-group">
                    <label>Seed</label>
                    <input type="text" id="item-seed" placeholder="Leave empty for random">
                    <button onclick="generateRandomSeed('item-seed')" style="margin-top: 5px; padding: 6px; font-size: 0.85em;">Random Seed</button>
                </div>
                <button class="button-primary" onclick="generateItems()">Generate Items</button>
            </div>

            <!-- Party Generation Controls -->
            <div id="party-controls" class="tab-controls" style="display: none;">
                <h2>Party Generation</h2>
                <div class="control-group">
                    <label>Party Size</label>
                    <input type="number" id="party-size" min="1" max="5" value="4">
                </div>
                <div class="control-group">
                    <label>Default Level</label>
                    <input type="range" id="party-level" min="1" max="20" value="5" oninput="document.getElementById('party-level-value').textContent = this.value">
                    <span class="slider-value" id="party-level-value">5</span>
                </div>
                <div class="control-group">
                    <label>Party Composition</label>
                    <div class="checkbox-group">
                        <div class="checkbox-item"><input type="checkbox" id="class-warrior" checked> <label for="class-warrior">Warrior</label></div>
                        <div class="checkbox-item"><input type="checkbox" id="class-mage" checked> <label for="class-mage">Mage</label></div>
                        <div class="checkbox-item"><input type="checkbox" id="class-rogue" checked> <label for="class-rogue">Rogue</label></div>
                        <div class="checkbox-item"><input type="checkbox" id="class-cleric" checked> <label for="class-cleric">Cleric</label></div>
                    </div>
                    <p style="color: #aaa; font-size: 0.85em; margin-top: 5px;">
                        Selected classes will be distributed evenly across party members.
                    </p>
                </div>
                <div class="control-group">
                    <label>Stat Generation</label>
                    <select id="stat-generation">
                        <option value="balanced" selected>Balanced (Point Buy)</option>
                        <option value="random">Random (3d6)</option>
                        <option value="heroic">Heroic (4d6 drop lowest)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Seed (Optional)</label>
                    <input type="text" id="party-seed" placeholder="Leave empty for random">
                    <button onclick="generateRandomSeed('party-seed')" style="margin-top: 5px; padding: 6px; font-size: 0.85em;">Random Seed</button>
                </div>
                <button class="button-primary" onclick="generateParty()">Generate Party</button>
            </div>

            <!-- Combat Simulation Controls -->
            <div id="combat-controls" class="tab-controls" style="display: none;">
                <h2>Combat Simulation</h2>
                <div style="background: #1a1a2e; padding: 15px; border-radius: 5px; margin-bottom: 15px; border: 1px solid #16213e;">
                    <p style="margin: 0; color: #aaa; line-height: 1.6;">
                        Simulate a party deterministically delving through a dungeon. Select a dungeon from the registry and a generated party.
                    </p>
                </div>
                <div class="control-group">
                    <label>Select Dungeon</label>
                    <select id="combat-dungeon-select" style="margin-bottom: 5px;">
                        <option value="">-- Select a dungeon --</option>
                    </select>
                    <p style="color: #aaa; font-size: 0.85em; margin: 5px 0;">
                        Generate a world with dungeons first, then select one here.
                    </p>
                </div>
                <div class="control-group">
                    <label>Select Party</label>
                    <select id="combat-party-select" style="margin-bottom: 5px;">
                        <option value="">-- Select a party --</option>
                    </select>
                    <p style="color: #aaa; font-size: 0.85em; margin: 5px 0;">
                        Generate a party in the Party Generation tab first.
                    </p>
                </div>
                <div class="control-group">
                    <label>Simulation Options</label>
                    <div class="checkbox-group">
                        <div class="checkbox-item"><input type="checkbox" id="sim-fast-mode" checked onchange="handleFastModeChange()"> <label for="sim-fast-mode">Fast Mode (Instant)</label></div>
                        <div class="checkbox-item"><input type="checkbox" id="sim-show-details" onchange="handleShowDetailsChange()"> <label for="sim-show-details">Show Detailed Combat Log</label></div>
                        <div class="checkbox-item"><input type="checkbox" id="sim-stop-on-defeat" checked> <label for="sim-stop-on-defeat">Stop on Party Defeat</label></div>
                    </div>
                    <p style="color: #aaa; font-size: 0.85em; margin-top: 5px;">
                        Fast Mode and Detailed Combat Log are mutually exclusive.
                    </p>
                </div>
                <div class="control-group">
                    <label>Cleric Heal Ratio</label>
                    <input type="range" id="cleric-heal-ratio" min="0" max="100" value="30" oninput="document.getElementById('cleric-heal-ratio-value').textContent = this.value + '%'">
                    <span class="slider-value" id="cleric-heal-ratio-value">30%</span>
                </div>
                <div class="control-group">
                    <label>Mage Magic Ratio</label>
                    <input type="range" id="mage-magic-ratio" min="0" max="100" value="70" oninput="document.getElementById('mage-magic-ratio-value').textContent = this.value + '%'">
                    <span class="slider-value" id="mage-magic-ratio-value">70%</span>
                </div>
                <button class="button-primary" onclick="simulateDungeonRun()">Run Simulation</button>
                <button onclick="clearCombatResults()" style="width: 100%; margin-top: 10px; padding: 10px; background: #1a1a2e; border: 2px solid #888; color: #aaa;">Clear Results</button>
            </div>
        </div>

        <!-- Main View Area -->
        <div class="main-view">
            <!-- World Generation Tab -->
            <div id="world-tab" class="tab-content active">
                <div class="loading" id="world-loading">Generating world...</div>
                <div id="world-results"></div>
            </div>

            <!-- Dungeon Registry Tab -->
            <div id="dungeon-tab" class="tab-content">
                <div class="loading" id="dungeon-loading">Loading dungeon registry...</div>
                <div id="dungeon-results"></div>
            </div>

            <!-- Item Generation Tab -->
            <div id="item-tab" class="tab-content">
                <div class="loading" id="item-loading">Generating items...</div>
                <div id="item-results"></div>
            </div>

            <!-- Party Generation Tab -->
            <div id="party-tab" class="tab-content">
                <div class="loading" id="party-loading">Generating party...</div>
                <div id="party-results"></div>
            </div>

            <!-- Combat Simulation Tab -->
            <div id="combat-tab" class="tab-content">
                <div class="loading" id="combat-loading">Preparing simulation...</div>
                <div id="combat-results"></div>
            </div>
        </div>

        <!-- Right Sidebar - Shared Context -->
        <div class="context-panel">
            <h3>Shared Context</h3>
            <div id="context-world" class="context-item" style="display: none;">
                <strong>World:</strong> <span id="context-world-seed">-</span><br>
                <small>Entities: <span id="context-world-count">0</span></small>
            </div>
            <div id="context-dungeon" class="context-item" style="display: none;">
                <strong>Dungeon Registry:</strong><br>
                <small>Dungeons: <span id="context-dungeon-count">0</span></small>
            </div>
            <div id="context-party" class="context-item" style="display: none;">
                <strong>Generated Party:</strong><br>
                <small>Members: <span id="context-party-count">0</span></small>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // SHARED UTILITIES
        // ============================================================================

        // Mulberry32 seeded RNG (consistent across all systems)
        function makeRng(seed) {
            if (!seed) seed = Math.random().toString(36).substring(2, 15);
            let hash = seed.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
            return function() {
                hash = (hash * 9301 + 49297) % 233280;
                return hash / 233280;
            };
        }

        // SeededRNG Class (Mulberry32) for more advanced use
        class SeededRNG {
            constructor(seed) {
                if (typeof seed === 'string') {
                    this.seed = this.hashString(seed);
                } else {
                    this.seed = seed || Math.floor(Math.random() * 0xFFFFFFFF);
                }
            }

            hashString(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return Math.abs(hash);
            }

            next() {
                let t = this.seed += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }

            random() {
                return this.next();
            }

            range(min, max) {
                return Math.floor(this.next() * (max - min + 1)) + min;
            }

            choice(array) {
                return array[Math.floor(this.next() * array.length)];
            }

            getSeed() {
                return this.seed;
            }
        }

        // Hash string to number
        function hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash);
        }

        // Generate random seed
        function generateRandomSeed(inputId) {
            const seed = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
            document.getElementById(inputId).value = seed;
        }

        // Shared context storage
        const sharedContext = {
            world: null,
            dungeon: null
        };
        
        // Tree toggle function - must be globally accessible
        function toggleTreeLevel(levelId) {
            // Find the toggle button first (it has the data-level-id attribute)
            const toggle = document.querySelector(`.tree-toggle[data-level-id="${levelId}"]`);
            if (!toggle) {
                console.error('Cannot find toggle button with data-level-id:', levelId);
                return;
            }

            // Find the parent tree-node from the toggle button
            const treeNode = toggle.closest('.tree-node');
            if (!treeNode) {
                console.error('Cannot find tree-node parent from toggle button');
                return;
            }

            // Find the children div by ID (same as levelId since data-level-id uses tree-level- prefix)
            const children = document.getElementById(levelId);
            if (!children) {
                console.error('Cannot find children element with id:', levelId);
                return;
            }

            // Verify the children div is within the same tree-node
            if (!treeNode.contains(children)) {
                console.error('Children div is not within the same tree-node as toggle');
                return;
            }

            // Toggle the expanded state
            if (children.classList.contains('expanded')) {
                children.classList.remove('expanded');
                toggle.textContent = 'Γû╢';
            } else {
                children.classList.add('expanded');
                toggle.textContent = 'Γû╝';
            }
        }
        
        // Make globally accessible
        window.toggleTreeLevel = toggleTreeLevel;
        
        

        // Tab switching
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => {
                const tabName = button.dataset.tab;
                
                // Update buttons
                document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                button.classList.add('active');
                
                // Update content
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                document.getElementById(tabName + '-tab').classList.add('active');
                
                // Update controls
                document.querySelectorAll('.tab-controls').forEach(ctrl => ctrl.style.display = 'none');
                document.getElementById(tabName + '-controls').style.display = 'block';
            });
        });

        // ============================================================================
        // ITEM GENERATION SYSTEM
        // ============================================================================

        /**
         * Item Generator Class
         * Ported from apps/web/contributions/procedural-item-generation/
         */
        class ItemGenerator {
            constructor(seed) {
                this.rng = new SeededRNG(seed);
                this.SCARCITY_CAP = 100;
                this.STORAGE_KEY = 'innkeeper_item_counts';
            }

            getItemCounts() {
                try {
                    const stored = localStorage.getItem(this.STORAGE_KEY);
                    if (stored) return JSON.parse(stored);
                } catch (e) {
                    console.warn('Failed to load item counts:', e);
                }
                return {
                    'Longsword': 0, 'Staff': 0, 'Dagger': 0, 'Mace': 0,
                    'Full Plate': 0, 'Chain Mail': 0, 'Mage Robes': 0, 'Enchanted Cloak': 0,
                    'Leather Armor': 0, 'Studded Leather': 0, 'Scale Mail': 0, 'Breastplate': 0,
                };
            }

            saveItemCounts(counts) {
                try {
                    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(counts));
                } catch (e) {
                    console.warn('Failed to save item counts:', e);
                }
            }

            incrementItemCount(itemType) {
                const counts = this.getItemCounts();
                if (counts[itemType] !== undefined && counts[itemType] < this.SCARCITY_CAP) {
                    counts[itemType]++;
                    this.saveItemCounts(counts);
                }
            }

            getAvailabilityWeight(itemType) {
                const counts = this.getItemCounts();
                const current = counts[itemType] || 0;
                return Math.max(0, this.SCARCITY_CAP - current);
            }

            getRarityDistribution(rarityModifier = 100) {
                const mod = rarityModifier / 100;
                return {
                    common: Math.max(0, 60 - (mod - 1) * 15),
                    uncommon: Math.max(0, 28 + (mod - 1) * 8),
                    rare: Math.max(0, 10 + (mod - 1) * 5),
                    epic: Math.max(0, 2 + (mod - 1) * 2),
                };
            }

            determineRarity(rarityModifier = 100) {
                const dist = this.getRarityDistribution(rarityModifier);
                const roll = this.rng.random() * 100;
                let cumulative = 0;
                const rarities = ['common', 'uncommon', 'rare', 'epic'];
                for (const rarity of rarities) {
                    cumulative += dist[rarity];
                    if (roll <= cumulative) return rarity;
                }
                return 'common';
            }

            selectCategory(context, classPreference) {
                const contextWeights = {
                    dungeon_loot: { weapon: 50, armor: 50 },
                    monster_drop: { weapon: 50, armor: 50 },
                    boss_drop: { weapon: 50, armor: 50 },
                    vendor: { weapon: 50, armor: 50 },
                    quest_reward: { weapon: 50, armor: 50 },
                };
                const weights = contextWeights[context] || contextWeights.dungeon_loot;
                const roll = this.rng.random() * 100;
                let cumulative = 0;
                for (const [cat, weight] of Object.entries(weights)) {
                    cumulative += weight;
                    if (roll <= cumulative) return cat;
                }
                return 'weapon';
            }

            generateItem(context, level, classPreference, rarityModifier, seed) {
                if (seed) this.rng = new SeededRNG(seed);
                const rarity = this.determineRarity(rarityModifier);
                const category = this.selectCategory(context, classPreference);
                
                let item;
                if (category === 'weapon') {
                    item = this.generateWeapon(rarity, level, classPreference);
                } else {
                    item = this.generateArmor(rarity, level, classPreference);
                }

                item.id = `item-${Date.now()}-${this.rng.range(1000, 9999)}`;
                item.rarity = rarity;
                item.category = category;
                item.level = level;
                item.context = context;
                item.seed = this.rng.getSeed();

                if (item.itemType) this.incrementItemCount(item.itemType);
                return item;
            }

            generateWeapon(rarity, level, classPreference) {
                const allWeapons = {
                    warrior: { type: 'Longsword', damage: 8, isMagic: false, requiredClass: 'warrior' },
                    mage: { type: 'Staff', damage: 6, isMagic: true, requiredClass: 'mage' },
                    rogue: { type: 'Dagger', damage: 4, isMagic: false, requiredClass: 'rogue' },
                    cleric: { type: 'Mace', damage: 6, isMagic: false, requiredClass: 'cleric' },
                };

                let candidateWeapons = classPreference === 'any' 
                    ? Object.values(allWeapons)
                    : [allWeapons[classPreference] || allWeapons.warrior];

                const weightedWeapons = candidateWeapons.map(w => ({
                    ...w,
                    weight: this.getAvailabilityWeight(w.type)
                }));

                const totalWeight = weightedWeapons.reduce((sum, w) => sum + w.weight, 0);
                let weapon = totalWeight === 0
                    ? this.rng.choice(candidateWeapons)
                    : this.selectWeighted(weightedWeapons, totalWeight);

                const rarityStats = {
                    common: { attackBonus: 0, enhancementCount: 0 },
                    uncommon: { attackBonus: 1, enhancementCount: 0 },
                    rare: { attackBonus: 2, enhancementCount: 1 },
                    epic: { attackBonus: 3, enhancementCount: 2 },
                };

                const stats = rarityStats[rarity];
                const attackBonus = stats.attackBonus + Math.floor(level / 5);
                const damageDice = `1d${weapon.damage} + ${attackBonus}`;
                const enhancements = this.generateEnhancements(stats.enhancementCount, rarity, level);

                return {
                    name: this.generateWeaponName(weapon.type, rarity, enhancements),
                    type: weapon.isMagic ? 'weapon (magic)' : 'weapon (melee)',
                    itemType: weapon.type,
                    requiredClass: weapon.requiredClass,
                    damage: damageDice,
                    attackBonus: `+${attackBonus}`,
                    properties: this.getWeaponProperties(weapon.type),
                    enhancements: enhancements,
                    description: this.generateWeaponDescription(weapon.type, rarity, enhancements),
                };
            }

            generateArmor(rarity, level, classPreference) {
                const allArmorKits = {
                    warrior: [
                        { type: 'Full Plate', baseAC: 8, armorType: 'Heavy', requiredClass: 'warrior' },
                        { type: 'Chain Mail', baseAC: 6, armorType: 'Medium', requiredClass: 'warrior' }
                    ],
                    mage: [
                        { type: 'Mage Robes', baseAC: 3, armorType: 'Light', requiredClass: 'mage' },
                        { type: 'Enchanted Cloak', baseAC: 2, armorType: 'Light', requiredClass: 'mage' }
                    ],
                    rogue: [
                        { type: 'Leather Armor', baseAC: 3, armorType: 'Light', requiredClass: 'rogue' },
                        { type: 'Studded Leather', baseAC: 4, armorType: 'Light', requiredClass: 'rogue' }
                    ],
                    cleric: [
                        { type: 'Scale Mail', baseAC: 6, armorType: 'Medium', requiredClass: 'cleric' },
                        { type: 'Breastplate', baseAC: 5, armorType: 'Medium', requiredClass: 'cleric' }
                    ],
                };

                let candidateArmor = classPreference === 'any'
                    ? Object.values(allArmorKits).flat()
                    : (allArmorKits[classPreference] || allArmorKits.warrior);

                const weightedArmor = candidateArmor.map(a => ({
                    ...a,
                    weight: this.getAvailabilityWeight(a.type)
                }));

                const totalWeight = weightedArmor.reduce((sum, a) => sum + a.weight, 0);
                let armor = totalWeight === 0
                    ? this.rng.choice(candidateArmor)
                    : this.selectWeighted(weightedArmor, totalWeight);

                const rarityStats = {
                    common: { acBonus: 0, enhancementCount: 0 },
                    uncommon: { acBonus: 1, enhancementCount: 0 },
                    rare: { acBonus: 2, enhancementCount: 1 },
                    epic: { acBonus: 3, enhancementCount: 2 },
                };

                const stats = rarityStats[rarity];
                const acBonus = armor.baseAC + stats.acBonus + Math.floor(level / 5);
                const enhancements = this.generateEnhancements(stats.enhancementCount, rarity, level);

                return {
                    name: this.generateArmorName(armor.type, rarity, enhancements),
                    type: 'armor',
                    itemType: armor.type,
                    requiredClass: armor.requiredClass,
                    ac: `+${acBonus}`,
                    properties: this.getArmorProperties(armor.type, armor.armorType),
                    enhancements: enhancements,
                    description: this.generateArmorDescription(armor.type, rarity, enhancements),
                };
            }

            selectWeighted(items, totalWeight) {
                let roll = this.rng.random() * totalWeight;
                let cumulative = 0;
                for (const item of items) {
                    cumulative += item.weight;
                    if (roll <= cumulative) return item;
                }
                return items[0];
            }

            generateEnhancements(count, rarity, level) {
                const enhancements = [];
                const allEnhancements = ['Flaming', 'Frost', 'Shock', 'Venomous', 'Regeneration', 'Lifesteal', 'Fortified', 'Swift'];
                for (let i = 0; i < count; i++) {
                    enhancements.push(this.rng.choice(allEnhancements));
                }
                return enhancements;
            }

            generateWeaponName(baseType, rarity, enhancements) {
                let name = baseType;
                if (enhancements.length > 0) name = `${enhancements[0]} ${name}`;
                if (rarity !== 'common') {
                    const rarityPrefixes = { uncommon: '+1', rare: '+2', epic: '+3' };
                    name += ` ${rarityPrefixes[rarity] || ''}`;
                }
                return name.trim();
            }

            generateArmorName(baseType, rarity, enhancements) {
                let name = baseType;
                if (enhancements.length > 0) name = `${baseType} of ${enhancements[0]}`;
                if (rarity === 'epic') {
                    const suffixes = ['Protection', 'the Guardian', 'Valor'];
                    name = `${name} ${this.rng.choice(suffixes)}`;
                }
                return name;
            }

            getWeaponProperties(baseType) {
                if (baseType === 'Dagger') return 'Finesse, Light';
                if (baseType === 'Staff') return 'Spell Focus, Two-handed';
                if (baseType === 'Longsword') return 'Versatile';
                if (baseType === 'Mace') return 'Standard';
                return 'Standard';
            }

            getArmorProperties(baseType, armorType) {
                let props = `${armorType} Armor`;
                if (armorType === 'Heavy') props += ', Stealth Disadvantage';
                return props;
            }

            generateWeaponDescription(baseType, rarity, enhancements) {
                let desc = `A ${rarity} ${baseType.toLowerCase()}.`;
                if (enhancements.length > 0) desc += ` It glows with ${enhancements[0].toLowerCase()} energy.`;
                return desc;
            }

            generateArmorDescription(baseType, rarity, enhancements) {
                return `A ${rarity} piece of ${baseType.toLowerCase()} that provides excellent protection.`;
            }
        }

        // ============================================================================
        // WORLD GENERATION SYSTEM (Simplified Implementation)
        // Full implementation would port all 9 levels from TypeScript
        // ============================================================================

        // Name templates (expanded from world-templates.ts)
        const WorldNameTemplates = {
            primordial: {
                space: ['The Void', 'The Abyss', 'The Emptiness', 'The Expanse', 'The Nothing', 'The Absence'],
                time: ['The Eternal', 'The Timeless', 'The Chronos', 'The Flow', 'The Infinite', 'The Forever', 'The Endless'],
                light: ['The Radiance', 'The Illumination', 'The Brilliance', 'The Dawn'],
                dark: ['The Shadow', 'The Darkness', 'The Night', 'The Void'],
                order: ['The Balance', 'The Structure', 'The Law', 'The Pattern'],
                chaos: ['The Chaos', 'The Entropy', 'The Disorder', 'The Wild'],
            },
            cosmic: {
                rock: ['Stone Shaper', 'Mountain Forger', 'The Granite One'],
                wind: ['Wind Rider', 'Sky Dancer', 'Storm Bringer'],
                water: ['Deep One', 'Tide Master', 'Wave Song'],
                life: ['Life Giver', 'The Sower', 'The Bloom'],
                fire: ['Flame Keeper', 'Ember Lord', 'Blaze', 'Inferno'],
                earth: ['The Earthen', 'Land Keeper', 'Terra'],
                ice: ['The Frost', 'The Cold One', 'The Glacier'],
                magic: ['The Arcane', 'The Weave', 'The Mystic', 'The Enchanter'],
            },
            geography: {
                continent: ['The Northern Wastes', 'The Eastern Lands', 'The Western Reaches', 'The Southern Expanse', 'The Central Continent'],
                ocean: ['The Endless Sea', 'The Deep Blue', 'The Vast Waters', 'The Great Ocean', 'The Northern Sea'],
                mountain_range: ["The Dragon's Spine", "The Titan's Back", 'The Sky Peaks', 'The Cloud Mountains', 'The Iron Peaks'],
                river: ['The Flowing Path', 'The Silver Stream', 'The River of Life', 'The Stream of Permanence', 'The Great River'],
                underground_system: ['The Deep Tunnels', 'The Underdark', 'The Caverns Below', 'The Subterranean', 'The Endless Caves'],
                forest: ['The Ancient Woods', 'The Whispering Trees', 'The Green Expanse', 'The Wild Forest', 'The Elderwood'],
                desert: ['The Endless Sands', 'The Burning Waste', 'The Dry Expanse', 'The Scorched Land', 'The Red Desert'],
                plains: ['The Rolling Fields', 'The Grasslands', 'The Wide Expanse', 'The Flatlands', 'The Golden Plains'],
                island: ['The Lonely Isle', 'The Hidden Land', 'The Isolated Rock', 'The Secluded Place', 'The Mysterious Isle'],
                volcano: ['Fire Mountain', 'Molten Peak', 'Burning Summit', 'Lava Forge', 'The Great Volcano'],
                swamp: ['The Murky Bog', 'The Fetid Marsh', 'The Dark Swamp', 'The Mire', 'The Cursed Swamp'],
                tundra: ['The Frozen Waste', 'The Ice Fields', 'The Permafrost', 'The Cold Expanse', 'The White Wastes'],
                canyon: ['The Great Chasm', 'The Deep Canyon', 'The Ravine', 'The Gorge', 'The Grand Canyon'],
                archipelago: ['The Island Chain', 'The Broken Isles', 'The Scattered Lands', 'The Cluster', 'The Thousand Isles'],
                fjord: ['The Deep Fjord', 'The Ice Fjord', 'The Northern Inlet', 'The Carved Bay', 'The Narrow Fjord'],
                steppe: ['The Open Steppe', 'The Grass Sea', 'The Wide Plains', 'The Endless Grass', 'The Golden Steppe'],
                jungle: ['The Dense Jungle', 'The Overgrown Wilds', 'The Lush Canopy', 'The Green Hell', 'The Untamed Jungle'],
                badlands: ['The Barren Badlands', 'The Eroded Waste', 'The Broken Land', 'The Desolate', 'The Red Badlands'],
                glacier: ['The Great Glacier', 'The Ice Sheet', 'The Frozen River', 'The Ice Wall', 'The Eternal Glacier'],
                marsh: ['The Wet Marsh', 'The Reedy Marsh', 'The Boggy Ground', 'The Soggy Land', 'The Quagmire'],
                plateau: ['The High Plateau', 'The Pedestal', 'The Table', 'The Mesa', 'The Sky Plateau'],
                coast: ['The Rocky Coast', 'The Sandy Shore', 'The Cliff Coast', 'The Coastal Edge', 'The Rugged Coast'],
                bay: ['The Sheltered Bay', 'The Deep Bay', 'The Calm Harbor', 'The Protected Inlet', 'The Safe Harbor'],
                peninsula: ['The Long Peninsula', 'The Narrow Land', 'The Jutting Land', 'The Extended Shore', 'The Curved Peninsula'],
            },
            conceptual: {
                luck: ['Lady Fortune', 'The Fortunate One', 'The Chance Bringer', 'The Lucky'],
                love: ["The Heart's Desire", 'The Love Bringer', 'The Passion', 'The Beloved'],
                fertility: ['The Harvest Mother', 'The Growth Keeper', 'The Fertile One', 'The Bountiful'],
                justice: ['The Just One', 'The Balance Keeper', 'The Law Giver', 'The Fair'],
                war: ['The War Bringer', 'The Battle Lord', 'The Conflict', 'The Warrior'],
                death: ['The Reaper', 'The End Bringer', 'The Final One', 'The Death Keeper'],
                wisdom: ['The Wise One', 'The Knowledge Keeper', 'The Sage', 'The Learned'],
                wealth: ['The Gold Keeper', 'The Treasure Lord', 'The Wealthy', 'The Rich'],
                art: ['The Artisan', 'The Creator', 'The Beauty Bringer', 'The Artist'],
                music: ['The Song Keeper', 'The Melody', 'The Harmony', 'The Singer'],
                craft: ['The Maker', 'The Crafter', 'The Builder', 'The Artisan'],
                hunting: ['The Hunter', 'The Stalker', 'The Pursuer', 'The Tracker'],
                harvest: ['The Reaper', 'The Gatherer', 'The Harvester', 'The Collector'],
                blood: ['The Blood God', 'The Crimson One', 'The Life Taker', 'The Red Lord'],
                vengeance: ['The Avenger', 'The Retribution', 'The Vengeful', 'The Wrath'],
                mercy: ['The Merciful', 'The Compassionate', 'The Forgiving', 'The Kind'],
                honor: ['The Honorable', 'The Noble', 'The Just', 'The Righteous'],
                courage: ['The Brave', 'The Courageous', 'The Valiant', 'The Fearless'],
                trade: ['The Merchant', 'The Trader', 'The Commerce', 'The Exchange'],
                nature: ['The Nature Keeper', 'The Wild One', 'The Green', 'The Natural'],
                magic: ['The Mage', 'The Sorcerer', 'The Arcane', 'The Mystical'],
                beauty: ['The Beautiful', 'The Fair', 'The Lovely', 'The Graceful'],
                strength: ['The Strong', 'The Mighty', 'The Powerful', 'The Forceful'],
                chaos: ['The Chaos', 'The Disorder', 'The Entropy', 'The Anarchy'],
                order: ['The Order', 'The Structure', 'The Law', 'The Pattern'],
                stone: ['The Stone', 'The Rock', 'The Granite', 'The Foundation'],
                metal: ['The Metal', 'The Forge', 'The Smith', 'The Iron'],
                mining: ['The Miner', 'The Excavator', 'The Digger', 'The Quarry'],
                smithing: ['The Smith', 'The Forge Master', 'The Metal Worker', 'The Craft'],
                trickery: ['The Trickster', 'The Deceiver', 'The Cunning', 'The Sly'],
                cunning: ['The Cunning', 'The Clever', 'The Sly', 'The Shrewd'],
                secrets: ['The Secret Keeper', 'The Hidden', 'The Concealed', 'The Mysterious'],
                stealth: ['The Shadow', 'The Stealth', 'The Hidden', 'The Unseen'],
                darkness: ['The Dark One', 'The Shadow', 'The Night', 'The Darkness'],
                forge: ['The Forge Master', 'The Fire Shaper', 'The Hammer', 'The Anvil'],
                forest: ['The Forest Lord', 'The Wood Keeper', 'The Grove', 'The Canopy'],
                life: ['The Life Giver', 'The Vital', 'The Living', 'The Breath'],
                growth: ['The Growth', 'The Blooming', 'The Flourishing', 'The Thriving'],
                battle: ['The Battle', 'The Combat', 'The Clash', 'The Conflict'],
                fury: ['The Fury', 'The Wrathful', 'The Furious', 'The Enraged'],
                beasts: ['The Beast Lord', 'The Wild', 'The Primal', 'The Animal'],
                greed: ['The Greedy', 'The Avaricious', 'The Covetous', 'The Grasping'],
                mischief: ['The Mischief', 'The Prankster', 'The Rascal', 'The Scamp'],
                comfort: ['The Comfort', 'The Cozy', 'The Warmth', 'The Ease'],
                home: ['The Hearth', 'The Home', 'The Hearth Keeper', 'The Homestead'],
                community: ['The Community', 'The Gathering', 'The Together', 'The Unity'],
                stories: ['The Storyteller', 'The Tale Keeper', 'The Narrative', 'The Legend'],
                invention: ['The Inventor', 'The Creator', 'The Innovator', 'The Designer'],
                curiosity: ['The Curious', 'The Seeker', 'The Wonderer', 'The Explorer'],
                tinkering: ['The Tinkerer', 'The Gadgeteer', 'The Fixer', 'The Mechanic'],
                wonder: ['The Wonder', 'The Marvel', 'The Astonishing', 'The Amazing'],
                survival: ['The Survivor', 'The Enduring', 'The Persevering', 'The Resilient'],
                traps: ['The Trap Master', 'The Snare', 'The Ambush', 'The Pit'],
                caves: ['The Cave Dweller', 'The Burrow', 'The Den', 'The Hollow'],
                hoarding: ['The Hoarder', 'The Collector', 'The Accumulator', 'The Gatherer'],
                servitude: ['The Servant', 'The Subservient', 'The Obedient', 'The Duty'],
                power: ['The Power', 'The Mighty', 'The Dominant', 'The Authority'],
                treasure: ['The Treasure', 'The Hoard', 'The Wealth', 'The Riches'],
                dominance: ['The Dominator', 'The Ruler', 'The Master', 'The Overlord'],
                ancient: ['The Ancient', 'The Old One', 'The Timeless', 'The Primeval'],
                sky: ['The Sky', 'The Heavens', 'The Firmament', 'The Celestial'],
                wind: ['The Wind', 'The Breeze', 'The Gust', 'The Gale'],
                travel: ['The Traveler', 'The Wanderer', 'The Journey', 'The Path'],
                heights: ['The Heights', 'The Summit', 'The Peak', 'The Elevation'],
                sea: ['The Sea', 'The Deep', 'The Ocean', 'The Waters'],
                water: ['The Water', 'The Flow', 'The Current', 'The Tide'],
                depths: ['The Depths', 'The Abyss', 'The Deep', 'The Underwater'],
                currents: ['The Current', 'The Flow', 'The Stream', 'The Rush'],
                mysteries: ['The Mystery', 'The Enigma', 'The Unknown', 'The Secret'],
            },
            standout: {
                hero: ['The Brave', 'The Valiant', 'The Hero', 'The Champion'],
                villain: ['The Dark One', 'The Evil', 'The Malicious', 'The Wicked'],
                wizard: ['Archmage', 'Grand Wizard', 'Master Mage', 'The Sorcerer'],
                archmage: ['Archmage', 'The Archmage', 'Master of Magic', 'The Supreme Mage'],
                king: ['King', 'The King', 'The Ruler', 'The Monarch'],
                war_chief: ['War Chief', 'The Warlord', 'The Battle Leader', 'The Commander'],
                vampire: ['The Vampire', 'The Blood Drinker', 'The Night Walker', 'The Immortal'],
                lich: ['The Lich', 'The Undead Lord', 'The Death Keeper', 'The Necromancer'],
                dragon_lord: ['Dragon Lord', 'The Wyrm', 'The Great Dragon', 'The Dragon King'],
                dungeon_boss: ['The Guardian', 'The Keeper', 'The Warden', 'The Protector'],
                necromancer: ['The Necromancer', 'The Death Mage', 'The Undead Master', 'The Death Caller'],
                oracle: ['The Oracle', 'The Seer', 'The Prophet', 'The Visionary'],
                prophet: ['The Prophet', 'The Foreteller', 'The Seer', 'The Visionary'],
            },
            demigod: {
                half_god: ['The Divine Child', 'The Half-Born', 'The Divine Mortal', 'The God-Touched'],
                ancient_creature: ['The First One', 'The Ancient', 'The Oldest', 'The Primeval'],
                divine_experiment: ['The Created', 'The Experiment', 'The Forged', 'The Made'],
                fallen_divine: ['The Fallen', 'The Cast Out', 'The Banished', 'The Exiled'],
                ascended_mortal: ['The Ascended', 'The Risen', 'The Elevated', 'The Transcended'],
                primordial_spawn: ['The Spawn', 'The Offspring', 'The Child', 'The Descendant'],
            },
        };

        function generateName(templates, seed, index, usedNames, rng) {
            // If usedNames tracking is provided, ensure uniqueness
            if (usedNames) {
                // Get available templates (not yet used)
                const availableTemplates = templates.filter(t => !usedNames.has(t));
                
                let finalName;
                
                if (availableTemplates.length > 0) {
                    // Random selection from available templates
                    const templateIndex = Math.floor((rng || new SeededRNG(seed + '-' + index)).random() * availableTemplates.length);
                    finalName = availableTemplates[templateIndex];
                } else {
                    // All templates used - need to create variants with descriptive suffixes
                    const rngInstance = rng || new SeededRNG(seed + '-' + index);
                    let baseTemplateIndex = Math.floor(rngInstance.random() * templates.length);
                    let baseName = templates[baseTemplateIndex];
                    
                    const descriptiveSuffixes = [
                        'the Elder', 'the Ancient', 'the First', 'the Last',
                        'the Great', 'the Lesser', 'the Old', 'the New',
                        'the Northern', 'the Southern', 'the Eastern', 'the Western',
                        'the Upper', 'the Lower', 'the Inner', 'the Outer',
                        'the Central', 'the Distant', 'the Hidden', 'the Lost',
                        'the Sacred', 'the Cursed', 'the Forbidden', 'the Forgotten'
                    ];
                    
                    let variantIndex = Math.floor(rngInstance.random() * descriptiveSuffixes.length);
                    let attempts = 0;
                    const maxAttempts = descriptiveSuffixes.length * 5;
                    
                    do {
                        // Try with single suffix first
                        finalName = `${baseName} ${descriptiveSuffixes[variantIndex]}`;
                        
                        // If that's taken and we've tried all single suffixes, try with double suffix
                        if (usedNames.has(finalName) && attempts >= descriptiveSuffixes.length) {
                            const secondSuffixes = ['of the North', 'of the South', 'of the East', 'of the West'];
                            const secondSuffix = secondSuffixes[Math.floor(rngInstance.random() * secondSuffixes.length)];
                            finalName = `${baseName} ${descriptiveSuffixes[variantIndex]} ${secondSuffix}`;
                        }
                        
                        variantIndex = (variantIndex + 1) % descriptiveSuffixes.length;
                        attempts++;
                    } while (usedNames.has(finalName) && attempts < maxAttempts);
                    
                    // Final check - if somehow still not unique, try a different base template
                    if (usedNames.has(finalName)) {
                        baseTemplateIndex = (baseTemplateIndex + 1) % templates.length;
                        baseName = templates[baseTemplateIndex];
                        finalName = `${baseName} ${descriptiveSuffixes[0]}`;
                        let fallbackAttempts = 0;
                        while (usedNames.has(finalName) && fallbackAttempts < descriptiveSuffixes.length) {
                            finalName = `${baseName} ${descriptiveSuffixes[fallbackAttempts]}`;
                            fallbackAttempts++;
                        }
                    }
                }
                
                usedNames.add(finalName);
                return finalName;
            }
            
            // No uniqueness tracking - just random selection
            const rngInstance = rng || new SeededRNG(seed + '-' + index);
            return rngInstance.choice(templates);
        }

        function generateWorld() {
            const loadingEl = document.getElementById('world-loading');
            const resultsEl = document.getElementById('world-results');
            
            loadingEl.classList.add('active');
            resultsEl.innerHTML = '';
            
            setTimeout(() => {
                try {
                    const seed = document.getElementById('world-seed').value || Math.random().toString(36);
                    const levels = [];
                    if (document.getElementById('level-1').checked) levels.push(1);
                    if (document.getElementById('level-2').checked) levels.push(2);
                    if (document.getElementById('level-2.5').checked) levels.push(2.5);
                    if (document.getElementById('level-3').checked) levels.push(3);
                    if (document.getElementById('level-4').checked) levels.push(4);
                    if (document.getElementById('level-5').checked) levels.push(5);
                    if (document.getElementById('level-6').checked) levels.push(6);
                    if (document.getElementById('level-6.5').checked) levels.push(6.5);
                    if (document.getElementById('level-7.5').checked) levels.push(7.5);
                    
                    // Auto-include dependencies
                    if ((levels.includes(3) || levels.includes(6) || levels.includes(6.5)) && !levels.includes(5)) {
                        levels.push(5); // Conceptual beings, organizations, and standout mortals need mortal races
                    }
                    if (levels.includes(6.5) && !levels.includes(6)) {
                        levels.push(6); // Standout mortals work better with organizations (optional but recommended)
                    }
                    if (levels.includes(4) && !levels.includes(1) && !levels.includes(2) && !levels.includes(3)) {
                        levels.push(1); // Demi-gods need primordials, cosmic creators, or conceptual beings (add primordials as base)
                        if (!levels.includes(2)) levels.push(2);
                    }
                    if (levels.includes(2.5) && !levels.includes(2)) {
                        levels.push(2); // Geography needs cosmic creators
                    }
                    if (levels.includes(2) && !levels.includes(1)) {
                        levels.push(1); // Cosmic creators need primordials
                    }
                    if (levels.includes(3) && !levels.includes(5)) {
                        levels.push(5); // Conceptual beings need mortal races
                    }
                    if (levels.includes(7.5) && !levels.includes(6.5)) {
                        levels.push(6.5); // Dungeons need standout mortals or organizations
                    }
                    if (levels.includes(7.5) && !levels.includes(6)) {
                        levels.push(6); // Dungeons benefit from organizations
                    }
                    
                    const world = generateWorldContent(seed, levels);
                    displayWorld(world);
                    
                    // Store in shared context
                    sharedContext.world = world;
                    updateContextPanel();
                    
                    loadingEl.classList.remove('active');
                } catch (error) {
                    console.error('Error generating world:', error);
                    resultsEl.innerHTML = `<div class="results-container"><h2 style="color: #ff4444;">Error Generating World</h2><div style="color: #aaa;">${error.message}</div><pre style="color: #888; margin-top: 10px;">${error.stack}</pre></div>`;
                    loadingEl.classList.remove('active');
                }
            }, 100);
        }

        function generateWorldContent(seed, levels) {
            const rng = new SeededRNG(seed);
            const world = {
                seed,
                primordials: [],
                cosmicCreators: [],
                geography: [],
                conceptualBeings: [],
                demiGods: [],
                mortalRaces: [],
                organizations: [],
                standoutMortals: [],
                dungeons: [],
                worldEvents: [],
                generatedAt: new Date(),
            };

            // Level 1: Primordials
            if (levels.includes(1)) {
                const types = ['space', 'time', 'light', 'dark', 'order', 'chaos'];
                types.forEach((type, idx) => {
                    const name = generateName(WorldNameTemplates.primordial[type], seed, idx);
                    world.primordials.push({
                        id: `primordial-${type}-${idx}`,
                        type: 'primordial',
                        primordialType: type,
                        name,
                        description: `${name} is the fundamental force of ${type}.`,
                    });
                });
            }

            // Level 2: Cosmic Creators
            if (levels.includes(2)) {
                const elements = ['rock', 'wind', 'water', 'life', 'fire', 'earth', 'ice', 'magic'];
                elements.forEach((element, idx) => {
                    // Assign to a primordial
                    let createdBy, primordialName;
                    if (element === 'ice' || element === 'magic') {
                        // Ice and magic get random primordial creators
                        const cosmicRng = new SeededRNG(seed + '-cosmic-' + element);
                        const randomIndex = cosmicRng.range(0, world.primordials.length - 1);
                        createdBy = world.primordials[randomIndex].id;
                        primordialName = world.primordials[randomIndex].name;
                    } else {
                        // Other elements use deterministic round-robin assignment
                        const primordialIndex = idx % world.primordials.length;
                        createdBy = world.primordials[primordialIndex].id;
                        primordialName = world.primordials[primordialIndex].name;
                    }
                    
                    const name = generateName(WorldNameTemplates.cosmic[element], seed, idx);
                    
                    let description;
                    if (element === 'magic') {
                        description = `${name} wove magic throughout the world, infusing the very fabric of reality with mystical power and arcane energy, created by ${primordialName}.`;
                    } else {
                        description = `${name} shaped the ${element} of the world, created by ${primordialName}.`;
                    }
                    
                    world.cosmicCreators.push({
                        id: `cosmic-${element}-${idx}`,
                        type: 'cosmic_creator',
                        element,
                        name,
                        description: description,
                        parentId: createdBy,
                        createdBy: createdBy,
                    });
                });
            }

            // Level 2.5: Geography
            if (levels.includes(2.5)) {
                const geoTypes = [
                    { type: 'continent', count: 3 },
                    { type: 'ocean', count: 2 },
                    { type: 'mountain_range', count: 5 },
                    { type: 'river', count: 8 },
                    { type: 'underground_system', count: 3 },
                    { type: 'forest', count: 6 },
                    { type: 'desert', count: 2 },
                    { type: 'plains', count: 4 },
                    { type: 'island', count: 3 },
                    { type: 'volcano', count: 2 },
                    { type: 'swamp', count: 3 },
                    { type: 'tundra', count: 2 },
                    { type: 'canyon', count: 4 },
                    { type: 'archipelago', count: 2 },
                    { type: 'fjord', count: 2 },
                    { type: 'steppe', count: 3 },
                    { type: 'jungle', count: 4 },
                    { type: 'badlands', count: 2 },
                    { type: 'glacier', count: 2 },
                    { type: 'marsh', count: 3 },
                    { type: 'plateau', count: 3 },
                    { type: 'coast', count: 6 },
                    { type: 'bay', count: 4 },
                    { type: 'peninsula', count: 3 },
                ];
                
                const getMagnitude = (type) => {
                    if (type === 'continent' || type === 'ocean') return 'vast';
                    if (['mountain_range', 'underground_system', 'forest', 'desert', 'tundra', 'canyon', 'steppe', 'jungle', 'glacier', 'plateau'].includes(type)) return 'large';
                    if (['island', 'volcano', 'bay'].includes(type)) return 'small';
                    return 'medium';
                };
                
                // Thematic mapping for geography to cosmic creators
                const elementMapping = {
                    ocean: ['water'], river: ['water'], swamp: ['water'], marsh: ['water'],
                    fjord: ['water'], bay: ['water'], coast: ['water'], peninsula: ['water'],
                    volcano: ['fire'], desert: ['fire'], badlands: ['fire'],
                    glacier: ['ice'], tundra: ['ice'],
                    forest: ['life'], jungle: ['life'], plains: ['life'], steppe: ['life'],
                    mountain_range: ['rock', 'earth'], canyon: ['rock', 'earth'],
                    plateau: ['rock', 'earth'], underground_system: ['rock', 'earth'],
                    continent: ['earth', 'rock'],
                    island: ['earth', 'water'], archipelago: ['water', 'earth'],
                };
                
                // Filter out magic creators - they don't create geography
                const geographyCreators = world.cosmicCreators.filter(c => c.element !== 'magic');
                
                const usedNames = new Set(); // Track used names to ensure uniqueness across all geography
                let geoIndex = 0;
                
                geoTypes.forEach(({ type, count }) => {
                    for (let i = 0; i < count; i++) {
                        // Find appropriate cosmic creator based on geography type
                        const preferredElements = elementMapping[type] || ['earth'];
                        let cosmicCreator = null;
                        
                        for (const element of preferredElements) {
                            cosmicCreator = geographyCreators.find(c => c.element === element);
                            if (cosmicCreator) break;
                        }
                        
                        // Fallback to round-robin if no preferred creator found
                        if (!cosmicCreator && geographyCreators.length > 0) {
                            cosmicCreator = geographyCreators[geoIndex % geographyCreators.length];
                        }
                        
                        const creatorName = cosmicCreator ? cosmicCreator.name : 'the cosmic forces';
                        
                        // Generate name with uniqueness tracking
                        const templates = WorldNameTemplates.geography[type] || ['Unknown ' + type];
                        const geoRng = new SeededRNG(seed + '-geo-' + geoIndex);
                        const name = generateName(templates, seed, geoIndex, usedNames, geoRng);
                        
                        world.geography.push({
                            id: `geo-${type}-${geoIndex}`,
                            type: 'geography',
                            geographyType: type,
                            name,
                            description: `${name} is a ${type.replace(/_/g, ' ')}, shaped by ${creatorName}.`,
                            magnitude: getMagnitude(type),
                            location: { x: geoRng.range(-100, 100), y: geoRng.range(-100, 100) }, // TODO: Remove - location generation will be replaced
                            parentId: cosmicCreator ? cosmicCreator.id : null,
                            createdBy: cosmicCreator ? cosmicCreator.id : null,
                        });
                        geoIndex++;
                    }
                });
            }

            // Level 5: Mortal Races (needed for conceptual beings and organizations)
            if (levels.includes(5)) {
                // Predefined cosmic creator to race mappings
                const cosmicCreatorRaces = {
                    life: ['human'],
                    earth: ['elf', 'halfling'],
                    rock: ['dwarf', 'gnome'],
                    fire: ['orc', 'goblin', 'kobold'],
                    wind: ['aarakocra', 'dragon'],
                    water: ['merfolk'],
                };
                
                const raceCharacteristics = {
                    human: { name: 'Human', homelandType: 'continent' },
                    elf: { name: 'Elf', homelandType: 'forest' },
                    halfling: { name: 'Halfling', homelandType: 'plains' },
                    dwarf: { name: 'Dwarf', homelandType: 'mountain_range' },
                    gnome: { name: 'Gnome', homelandType: 'forest' },
                    orc: { name: 'Orc', homelandType: 'desert' },
                    goblin: { name: 'Goblin', homelandType: 'underground_system' },
                    kobold: { name: 'Kobold', homelandType: 'underground_system' },
                    aarakocra: { name: 'Aarakocra', homelandType: 'mountain_range' },
                    dragon: { name: 'Dragon', homelandType: 'mountain_range' },
                    merfolk: { name: 'Merfolk', homelandType: 'ocean' },
                };
                
                world.mortalRaces = [];
                let raceIndex = 0;
                
                // Generate races based on predefined arrangements
                world.cosmicCreators.forEach(creator => {
                    const racesForCreator = cosmicCreatorRaces[creator.element] || [];
                    
                    racesForCreator.forEach(raceType => {
                        const raceData = raceCharacteristics[raceType];
                        if (!raceData) return;
                        
                        const homeland = world.geography.find(g => g.geographyType === raceData.homelandType)?.id || null;
                        const raceRng = new SeededRNG(seed + '-race-' + raceIndex);
                        
                        world.mortalRaces.push({
                            id: `race-${raceType}-${raceIndex}`,
                            type: 'mortal_race',
                            name: raceData.name,
                            raceType: raceType,
                            homeland: homeland,
                            description: `The ${raceData.name} were created by ${creator.name}.`,
                            createdAt: new Date(-3000 + (raceIndex * -100)),
                            parentId: creator.id,
                            createdBy: creator.id,
                        });
                        raceIndex++;
                    });
                });
            }
            
            // Level 3: Conceptual Beings (requires mortal races)
            if (levels.includes(3) && world.mortalRaces.length > 0) {
                const raceConceptPreferences = {
                    'Human': ['war', 'justice', 'love', 'wealth', 'trade', 'courage', 'honor', 'fertility', 'harvest'],
                    'Dwarf': ['craft', 'forge', 'stone', 'metal', 'mining', 'smithing', 'wealth', 'honor', 'order'],
                    'Elf': ['nature', 'forest', 'wisdom', 'magic', 'art', 'music', 'beauty', 'life', 'growth'],
                    'Orc': ['war', 'battle', 'blood', 'strength', 'rage', 'fury', 'chaos', 'hunting', 'beasts'],
                    'Goblin': ['trickery', 'cunning', 'secrets', 'stealth', 'greed', 'chaos', 'darkness', 'mischief'],
                    'Halfling': ['comfort', 'home', 'community', 'stories', 'feast', 'joy', 'peace', 'love', 'harvest'],
                    'Gnome': ['invention', 'curiosity', 'tinkering', 'wonder', 'knowledge', 'craft', 'art', 'magic', 'wisdom'],
                    'Kobold': ['survival', 'traps', 'caves', 'hoarding', 'servitude', 'cunning', 'secrets', 'darkness', 'fear'],
                    'Dragon': ['power', 'treasure', 'dominance', 'ancient', 'magic', 'wisdom', 'strength', 'hoarding', 'beasts'],
                    'Aarakocra': ['sky', 'wind', 'freedom', 'travel', 'heights', 'nature', 'peace', 'wisdom', 'joy'],
                    'Merfolk': ['sea', 'water', 'depths', 'currents', 'mysteries', 'beauty', 'nature', 'life', 'healing'],
                };
                
                world.conceptualBeings = [];
                const usedNames = new Set(); // Track used names to ensure uniqueness
                let conceptIndex = 0;
                
                const allConcepts = [
                    'luck', 'love', 'fertility', 'justice', 'war', 'death', 'wisdom', 'wealth',
                    'art', 'music', 'craft', 'hunting', 'harvest', 'blood', 'party', 'sacrifice',
                    'vengeance', 'mercy', 'betrayal', 'loyalty', 'honor', 'courage', 'fear',
                    'madness', 'healing', 'disease', 'plague', 'famine', 'feast', 'celebration',
                    'mourning', 'grief', 'joy', 'rage', 'peace', 'chaos', 'order', 'freedom',
                    'tyranny', 'hope', 'despair', 'truth', 'lies', 'secrets', 'knowledge',
                    'ignorance', 'beauty', 'ugliness', 'strength', 'weakness', 'cunning', 'stupidity',
                    'trade', 'forge', 'stone', 'metal', 'mining', 'smithing', 'nature', 'forest',
                    'magic', 'life', 'growth', 'battle', 'fury', 'beasts', 'trickery', 'stealth',
                    'greed', 'darkness', 'mischief', 'comfort', 'home', 'community', 'stories',
                    'invention', 'curiosity', 'tinkering', 'wonder', 'survival', 'traps', 'caves',
                    'hoarding', 'servitude', 'power', 'treasure', 'dominance', 'ancient', 'sky',
                    'wind', 'travel', 'heights', 'sea', 'water', 'depths', 'currents', 'mysteries',
                ];
                
                world.mortalRaces.forEach((race, raceIdx) => {
                    const raceName = race.name;
                    const raceType = race.raceType || raceName;
                    const preferredConcepts = raceConceptPreferences[raceName] || 
                                            raceConceptPreferences[raceType] ||
                                            ['wisdom', 'strength', 'courage'];
                    const conceptRng = new SeededRNG(seed + '-concept-' + raceName);
                    const numBeings = 2 + conceptRng.range(0, 2); // 2-4 beings per race
                    
                    const selectedConcepts = [];
                    // Select from preferred concepts first
                    for (let i = 0; i < numBeings && i < preferredConcepts.length; i++) {
                        const conceptIndex = Math.floor(conceptRng.random() * preferredConcepts.length);
                        const concept = preferredConcepts[conceptIndex];
                        if (!selectedConcepts.includes(concept)) {
                            selectedConcepts.push(concept);
                        }
                    }
                    
                    // Fill remaining slots from all available concepts if needed
                    while (selectedConcepts.length < numBeings) {
                        const concept = allConcepts[Math.floor(conceptRng.random() * allConcepts.length)];
                        if (!selectedConcepts.includes(concept)) {
                            selectedConcepts.push(concept);
                        }
                    }
                    
                    selectedConcepts.forEach((concept, idx) => {
                        const templates = WorldNameTemplates.conceptual[concept] || [`The ${concept.charAt(0).toUpperCase() + concept.slice(1)}`];
                        const name = generateName(templates, seed, conceptIndex, usedNames, conceptRng);
                        
                        world.conceptualBeings.push({
                            id: `conceptual-${raceName}-${concept}-${conceptIndex}`,
                            type: 'conceptual',
                            conceptualType: concept,
                            name,
                            description: `${name} is a god of ${concept}, born from the worship and beliefs of the ${raceName}. As the ${raceName} began to believe in ${concept}, their collective faith gave form to this conceptual being.`,
                            parentId: race.id,
                            domain: concept,
                            worshipedBy: [race.id],
                        });
                        conceptIndex++;
                    });
                });
            }
            
            // Level 6: Organizations (requires mortal races and geography)
            if (levels.includes(6) && world.mortalRaces.length > 0 && world.geography.length > 0) {
                const density = document.getElementById('organization-density').value || 'normal';
                const multipliers = { sparse: 0.5, normal: 1.0, dense: 1.5 };
                const multiplier = multipliers[density];
                
                const raceOrgTypes = {
                    'human': ['kingdom', 'city', 'town', 'guild'],
                    'dwarf': ['kingdom', 'city', 'guild', 'clan'],
                    'elf': ['realm', 'city', 'tribe', 'circle'],
                    'orc': ['horde', 'tribe', 'stronghold'],
                    'goblin': ['tribe', 'nest', 'band'],
                };
                
                world.organizations = [];
                let orgIndex = 0;
                
                world.mortalRaces.forEach((race, raceIdx) => {
                    const raceType = race.raceType.toLowerCase();
                    const availableTypes = raceOrgTypes[raceType] || ['kingdom', 'city', 'tribe'];
                    const orgRng = new SeededRNG(seed + '-org-' + race.name);
                    const orgCount = Math.ceil((2 + orgRng.range(0, 2)) * multiplier);
                    
                    for (let i = 0; i < orgCount; i++) {
                        const orgType = orgRng.choice(availableTypes);
                        const locationGeo = world.geography[orgIndex % world.geography.length];
                        
                        // Generate organization name
                        const orgNamePrefixes = {
                            kingdom: ['The Kingdom of', 'The Realm of', 'The Domain of'],
                            city: ['The City of', 'The Great City of', 'The Fortress of'],
                            horde: ['The Red Horde', 'The War Horde', 'The Battle Horde'],
                            realm: ['The Elven Realm', 'The Fey Realm', 'The Mystic Realm'],
                            town: ['The Town of', 'The Settlement of', 'The Village of'],
                            tribe: ['The Tribe of', 'The Clan of', 'The People of'],
                            guild: ["The Mage's Guild", "The Thieves' Guild", "The Warriors' Guild"],
                        };
                        
                        const prefix = orgRng.choice(orgNamePrefixes[orgType] || ['The']);
                        const geoName = locationGeo ? locationGeo.name : 'Unknown';
                        let orgName = orgType === 'guild' || orgType === 'horde' ? prefix : `${prefix} ${geoName}`;
                        // Fix "The The" issue - if name starts with "The The", insert "Flag of" between them
                        if (orgName.startsWith('The The ')) {
                            orgName = orgName.replace(/^The The /, 'The Flag of The ');
                        }
                        
                        world.organizations.push({
                            id: `org-${orgType}-${orgIndex}`,
                            type: 'organization',
                            magnitude: orgType,
                            name: orgName,
                            description: `${orgName} is a ${orgType} of the ${race.name}, established in ${locationGeo ? locationGeo.name : 'unknown lands'}.`,
                            parentId: locationGeo ? locationGeo.id : null,
                            race: race.id,
                            location: locationGeo ? locationGeo.id : '',
                            members: orgRng.range(100, 1000),
                        });
                        
                        orgIndex++;
                    }
                });
            }
            
            // Level 4: Demi-Gods (requires primordials, cosmic creators, or conceptual beings)
            if (levels.includes(4)) {
                if (world.cosmicCreators.length === 0 && world.conceptualBeings.length === 0 && world.primordials.length === 0) {
                    // Skip if no valid origin
                    world.demiGods = [];
                } else {
                    world.demiGods = [];
                    const demiGodTypes = ['half_god', 'ancient_creature', 'divine_experiment', 'fallen_divine', 'ascended_mortal', 'primordial_spawn'];
                    const divineExperimentCreators = new Set();
                    const usedNames = new Set(); // Track used names to prevent duplicates
                    let demiGodIndex = 0;
                    
                    demiGodTypes.forEach((demiGodType, typeIndex) => {
                        const baseCount = [2, 3, 2, 1, 1, 1][typeIndex];
                        const demiGodTypeRng = new SeededRNG(seed + '-demigod-type-' + typeIndex);
                        const count = baseCount + Math.floor(demiGodTypeRng.random() * 2); // 1-3 per type
                        
                        for (let i = 0; i < count; i++) {
                            const demiGodRng = new SeededRNG(seed + '-demigod-' + demiGodType + '-' + i);
                            
                            // Generate name with uniqueness tracking
                            const templates = WorldNameTemplates.demigod && WorldNameTemplates.demigod[demiGodType]
                                ? WorldNameTemplates.demigod[demiGodType]
                                : ['The Demi-God'];
                            const name = generateName(templates, seed, demiGodIndex, usedNames, demiGodRng);
                            demiGodIndex++;
                            
                            // Select origin
                            let originId = 'unknown';
                            if (demiGodType === 'half_god' || demiGodType === 'ascended_mortal') {
                                if (world.conceptualBeings.length > 0) {
                                    originId = world.conceptualBeings[demiGodRng.range(0, world.conceptualBeings.length - 1)].id;
                                } else if (world.cosmicCreators.length > 0) {
                                    originId = world.cosmicCreators[demiGodRng.range(0, world.cosmicCreators.length - 1)].id;
                                }
                            } else if (demiGodType === 'divine_experiment') {
                                const available = world.cosmicCreators.filter(c => !divineExperimentCreators.has(c.id));
                                if (available.length > 0) {
                                    originId = available[demiGodRng.range(0, available.length - 1)].id;
                                    divineExperimentCreators.add(originId);
                                } else if (world.cosmicCreators.length > 0) {
                                    originId = world.cosmicCreators[demiGodRng.range(0, world.cosmicCreators.length - 1)].id;
                                }
                            } else if (demiGodType === 'primordial_spawn' && world.primordials.length > 0) {
                                originId = world.primordials[demiGodRng.range(0, world.primordials.length - 1)].id;
                            } else if (world.cosmicCreators.length > 0) {
                                originId = world.cosmicCreators[demiGodRng.range(0, world.cosmicCreators.length - 1)].id;
                            } else if (world.primordials.length > 0) {
                                originId = world.primordials[demiGodRng.range(0, world.primordials.length - 1)].id;
                            }
                            
                            // Generate subtype and description
                            let subtype = {};
                            let description = '';
                            let powers = [];
                            let alignment = 'neutral';
                            let age = 1000;
                            
                            if (demiGodType === 'half_god') {
                                // Check if origin is a conceptual being - if so, restrict to that race
                                const conceptualBeing = world.conceptualBeings.find(cb => cb.id === originId);
                                if (conceptualBeing && conceptualBeing.worshipedBy && conceptualBeing.worshipedBy.length > 0) {
                                    // Get the race that worshiped this conceptual being
                                    const worshipingRaceId = conceptualBeing.worshipedBy[0];
                                    const worshipingRace = world.mortalRaces.find(r => r.id === worshipingRaceId);
                                    
                                    if (worshipingRace) {
                                        // Map race type to half-god race
                                        const raceTypeToHalfGodRace = {
                                            'human': 'human',
                                            'elf': 'elf',
                                            'dwarf': 'dwarf',
                                            'orc': 'orc',
                                            'goblin': 'goblin',
                                            'halfling': 'halfling',
                                            'gnome': 'gnome',
                                            'dragon': 'dragon',
                                            'fey': 'fey',
                                            'giant': 'giant',
                                            'tiefling': 'tiefling',
                                            'aasimar': 'aasimar',
                                            'genasi': 'genasi',
                                            'kobold': 'kobold',
                                            'lizardfolk': 'lizardfolk',
                                            'yuan_ti': 'yuan_ti',
                                            'kenku': 'kenku',
                                            'drow': 'elf',
                                            'wood_elf': 'elf',
                                            'high_elf': 'elf',
                                            'deep_gnome': 'gnome',
                                            'rock_gnome': 'gnome',
                                            'forest_gnome': 'gnome',
                                            'orc_variant': 'orc',
                                            'tabaxi': 'fey',
                                            'triton': 'genasi',
                                            'goliath': 'giant',
                                            'bugbear': 'goblin',
                                            'hobgoblin': 'goblin',
                                            'undead': 'undead',
                                            'construct': 'construct',
                                            'elemental': 'elemental',
                                        };
                                        
                                        subtype.halfGodRace = raceTypeToHalfGodRace[worshipingRace.raceType] || 'human';
                                    } else {
                                        // Fallback if race not found
                                        subtype.halfGodRace = 'human';
                                    }
                                } else {
                                    // For non-conceptual origins (primordials, cosmic creators), allow any race
                                    const races = ['human', 'elf', 'dwarf', 'orc', 'dragon', 'fey', 'giant', 'tiefling', 'aasimar', 'genasi', 'kobold', 'lizardfolk'];
                                    subtype.halfGodRace = races[demiGodRng.range(0, races.length - 1)];
                                }
                                
                                description = `${name} is a half-divine being, born of divine essence and ${subtype.halfGodRace} blood, bridging the mortal and divine realms.`;
                                powers = ['Divine Magic', 'Mortal Empathy', 'Immortal Longevity'];
                                alignment = demiGodRng.random() > 0.66 ? 'evil' : (demiGodRng.random() > 0.33 ? 'neutral' : 'good');
                                age = demiGodRng.range(100, 5000);
                            } else if (demiGodType === 'ancient_creature') {
                                const creatures = ['hydra', 'kraken', 'phoenix', 'colossus', 'leviathan', 'behemoth', 'basilisk', 'chimera', 'griffin', 'roc', 'sphinx', 'wyvern', 'manticore', 'cerberus', 'pegasus', 'unicorn', 'dragon_turtle', 'tarrasque'];
                                subtype.ancientCreatureType = creatures[demiGodRng.range(0, creatures.length - 1)];
                                const creatureNames = {
                                    hydra: 'a many-headed serpent', phoenix: 'an immortal fire bird',
                                    kraken: 'a colossal sea monster', colossus: 'a giant stone guardian',
                                    leviathan: 'a massive sea serpent', behemoth: 'a titanic land beast',
                                    basilisk: 'a deadly serpent king', chimera: 'a fire-breathing hybrid',
                                    griffin: 'a noble eagle-lion hybrid', roc: 'a gigantic bird of prey',
                                    sphinx: 'a wise riddle-keeper', wyvern: 'a two-legged dragon',
                                    manticore: 'a man-eating beast', cerberus: 'a three-headed hound',
                                    pegasus: 'a winged horse', unicorn: 'a pure horned steed',
                                    dragon_turtle: 'a massive armored sea dragon', tarrasque: 'an unstoppable world-ender'
                                };
                                description = `${name} is ${creatureNames[subtype.ancientCreatureType] || 'an ancient creature'}, one of the first creatures born at the dawn of creation.`;
                                powers = ['Ancient Strength', 'Primal Power'];
                                if (subtype.ancientCreatureType === 'phoenix') { powers = ['Immortal Rebirth', 'Flame Mastery']; alignment = 'good'; }
                                else if (subtype.ancientCreatureType === 'unicorn') { alignment = 'good'; }
                                else if (subtype.ancientCreatureType === 'tarrasque' || subtype.ancientCreatureType === 'manticore') { alignment = 'evil'; }
                                age = demiGodRng.range(1000000, 10000000);
                            } else if (demiGodType === 'divine_experiment') {
                                const allFeatures = ['scales', 'fur', 'feathers', 'claws', 'fangs', 'horns', 'tentacles', 'tail', 'wings', 'venom', 'multiple_heads', 'gills'];
                                const featureCount = demiGodRng.range(3, 7);
                                subtype.divineExperimentFeatures = [];
                                const available = [...allFeatures];
                                for (let f = 0; f < featureCount && available.length > 0; f++) {
                                    const idx = demiGodRng.range(0, available.length - 1);
                                    subtype.divineExperimentFeatures.push(available[idx]);
                                    available.splice(idx, 1);
                                }
                                description = `${name} is a divine experiment, a creature forged by the gods combining features from multiple beings.`;
                                if (subtype.divineExperimentFeatures.includes('wings')) powers.push('Flight');
                                if (subtype.divineExperimentFeatures.includes('venom')) powers.push('Venomous Attack');
                                if (subtype.divineExperimentFeatures.includes('multiple_heads')) powers.push('Multi-Sight', 'Multiple Attacks');
                                powers.push('Divine Resilience', 'Hybrid Form');
                                alignment = demiGodRng.random() > 0.7 ? 'evil' : 'neutral';
                                age = demiGodRng.range(500000, 5000000);
                            } else if (demiGodType === 'fallen_divine') {
                                const fallenTypes = ['fallen_angel', 'risen_demon', 'lost_celestial', 'corrupted_seraph', 'exiled_archon', 'tainted_deva', 'dark_angel', 'infernal_being'];
                                subtype.fallenDivineType = fallenTypes[demiGodRng.range(0, fallenTypes.length - 1)];
                                description = `${name} is a once-celestial being, cast out from the divine realm and now dwelling in the mortal world.`;
                                powers = ['Dark Light Manipulation', 'Immortal Resilience', 'Fallen Grace'];
                                alignment = 'evil';
                                age = demiGodRng.range(10000, 100000);
                            } else if (demiGodType === 'ascended_mortal') {
                                description = `${name} is a mortal who achieved divinity through great deeds, sacrifice, or divine favor, transcending the limits of mortality.`;
                                powers = ['Divine Authority', 'Mortal Empathy', 'Heroic Legacy'];
                                alignment = demiGodRng.random() > 0.66 ? 'evil' : (demiGodRng.random() > 0.33 ? 'neutral' : 'good');
                                age = demiGodRng.range(100, 10000);
                            } else if (demiGodType === 'primordial_spawn') {
                                const spawnTypes = ['void_spawn', 'chaos_born', 'order_manifest', 'time_child', 'space_fragment', 'light_shard', 'dark_essence', 'eternity_echo'];
                                subtype.primordialSpawnType = spawnTypes[demiGodRng.range(0, spawnTypes.length - 1)];
                                description = `${name} is born from primordial forces, a direct offspring of the forces that shaped existence.`;
                                powers = ['Reality Distortion', 'Primordial Power', 'Formless Shape'];
                                alignment = demiGodRng.random() > 0.66 ? 'evil' : (demiGodRng.random() > 0.33 ? 'neutral' : 'good');
                                age = demiGodRng.range(5000000, 50000000);
                            }
                            
                            world.demiGods.push({
                                id: `demigod-${demiGodType}-${demiGodIndex}`,
                                type: 'demigod',
                                demiGodType: demiGodType,
                                name: name,
                                description: description,
                                parentId: originId,
                                origin: originId,
                                age: age,
                                powers: powers,
                                alignment: alignment,
                                isBoss: alignment === 'evil', // Evil demi-gods are dungeon boss candidates
                                ...subtype,
                                createdAt: new Date(),
                            });
                        }
                    });
                }
            }
            
            // Level 6.5: Standout Mortals (requires mortal races and organizations)
            if (levels.includes(6.5) && world.mortalRaces.length > 0) {
                // Helper function to get race names
                const getRaceNames = (raceName) => {
                    const namePools = {
                        'Human': {
                            firstNames: ['Aethelred', 'Isolde', 'Valerius', 'Elena', 'Marcus', 'Sophia', 'Theodore', 'Victoria', 'Adrian', 'Alabaster', 'Benedict', 'Catherine', 'Darius', 'Eleanor', 'Frederick', 'Gwendolyn', 'Harold', 'Isabella', 'Julian', 'Katherine'],
                            lastNames: ['Alabaster', 'Blackwood', 'Brightblade', 'Goldleaf', 'Ironheart', 'Stormwind', 'Thornwood', 'Whitehall', 'Silvermoon', 'Dragonheart', 'Fireforge', 'Shadowvale', 'Brightwood', 'Crystalpeak', 'Stonethrone'],
                        },
                        'Dwarf': {
                            firstNames: ['Thorgrim', 'Borin', 'Helga', 'Grimbold', 'Thorin', 'Dagna', 'Balder', 'Frida', 'Gunnar', 'Hilda', 'Ivar', 'Kara', 'Magnus', 'Nora', 'Olaf'],
                            lastNames: ['Ironforge', 'Stonehammer', 'Goldbeard', 'Deepforge', 'Thunderaxe', 'Granitehold', 'Ironbeard', 'Stonefist', 'Goldhammer', 'Deepstone', 'Thunderforge', 'Ironhold'],
                        },
                        'Elf': {
                            firstNames: ['Aeliana', 'Thalius', 'Lyralei', 'Elandris', 'Sylvan', 'Arielle', 'Caladriel', 'Eldrin', 'Faelan', 'Galadriel', 'Ithilien', 'Lothiriel', 'Mithrandir', 'Nimrodel', 'Orophin'],
                            lastNames: ['Moonwhisper', 'Starweaver', 'Lightbreeze', 'Silverleaf', 'Shadowglen', 'Dawnblade', 'Starlight', 'Moonbeam', 'Sunfire', 'Windrider', 'Cloudwalker', 'Stormcaller'],
                        },
                        'Orc': {
                            firstNames: ['Grubnak', 'Bloodaxe', 'Skullcrusher', 'Grimjaw', 'Bonebreaker', 'Gorefang', 'Ironjaw', 'Ragefist', 'Skullsplitter', 'Warhammer', 'Deathclaw', 'Brutal'],
                            lastNames: ['Bloodfang', 'Skullcrusher', 'Ironjaw', 'Goreaxe', 'Bonebreaker', 'Deathclaw', 'Ragefist', 'Warhammer', 'Brutal', 'Grimjaw'],
                        },
                        'Goblin': {
                            firstNames: ['Snikkit', 'Gribble', 'Nix', 'Zog', 'Sneak', 'Grab', 'Quick', 'Sharp', 'Trick', 'Sly'],
                            lastNames: ['Quickfinger', 'Sharpnose', 'Greedygrab', 'Sneakypaw', 'Trickfoot', 'Slyhand', 'Grabby', 'Quickpaw'],
                        },
                        'Halfling': {
                            firstNames: ['Bilbo', 'Frodo', 'Merry', 'Pippin', 'Samwise', 'Rosie', 'Peregrin', 'Meriadoc', 'Hamfast', 'Bell'],
                            lastNames: ['Greenbottle', 'Goldcup', 'Merryweather', 'Quickstep', 'Goodbarrel', 'Underhill', 'Baggins', 'Took'],
                        },
                        'Gnome': {
                            firstNames: ['Fizzle', 'Gizmo', 'Tinker', 'Sparkle', 'Cog', 'Gear', 'Spring', 'Wind', 'Bell', 'Chip'],
                            lastNames: ['Cogwheel', 'Gearbox', 'Springwind', 'Tinkerbell', 'Clockwork', 'Gadget', 'Widget', 'Sprocket'],
                        },
                        'Kobold': {
                            firstNames: ['Snik', 'Grik', 'Zik', 'Tik', 'Krik', 'Nix', 'Pix', 'Rix'],
                            lastNames: ['Quickclaw', 'Sharpfang', 'Sneakscale', 'Tricktail', 'Grabby', 'Quickpaw'],
                        },
                        'Dragon': {
                            firstNames: ['Draconis', 'Ignis', 'Frost', 'Storm', 'Shadow', 'Gold', 'Silver', 'Iron'],
                            lastNames: ['Flameheart', 'Frostwing', 'Stormscale', 'Shadowclaw', 'Goldhoard', 'Ironhide', 'Dragonfire', 'Wyrmheart'],
                        },
                        'Aarakocra': {
                            firstNames: ['Aeris', 'Zephyr', 'Sky', 'Wind', 'Cloud', 'Storm', 'Gale', 'Breeze'],
                            lastNames: ['Skywing', 'Windrider', 'Clouddancer', 'Stormcaller', 'Galeheart', 'Breezeflight', 'Skysoar', 'Windwhisper'],
                        },
                        'Merfolk': {
                            firstNames: ['Aqua', 'Marina', 'Coral', 'Wave', 'Tide', 'Current', 'Deep', 'Pearl'],
                            lastNames: ['Deepwater', 'Coralreef', 'Wavecrest', 'Tidecaller', 'Currentflow', 'Pearlscale', 'Seadancer', 'Oceanheart'],
                        },
                    };
                    return namePools[raceName] || { firstNames: ['Unknown'], lastNames: ['Unknown'] };
                };
                
                // Helper function to get title for type
                const getTitleForType = (type) => {
                    const titles = {
                        king: 'King', queen: 'Queen', prince: 'Prince', princess: 'Princess',
                        emperor: 'Emperor', empress: 'Empress', founder: 'Founder',
                        general: 'General', commander: 'Commander', war_chief: 'War-Chief',
                        marshal: 'Marshal', admiral: 'Admiral',
                        knight: 'Knight', champion: 'Champion', hero: 'The Hero',
                        dragon_slayer: 'Dragon Slayer', giant_slayer: 'Giant Slayer',
                        demon_slayer: 'Demon Slayer', monster_slayer: 'Monster Slayer',
                        savior: 'The Savior', protector: 'The Protector', guardian: 'The Guardian',
                        wizard: 'Wizard', archmage: 'Archmage', necromancer: 'Necromancer',
                        lich: 'Lich', sorcerer: 'Sorcerer', warlock: 'Warlock',
                        witch: 'Witch', enchanter: 'Enchanter', alchemist: 'Alchemist',
                        villain: 'The Villain', vampire: 'Vampire Lord',
                        high_priest: 'High Priest', oracle: 'Oracle', prophet: 'Prophet',
                    };
                    return titles[type] || 'The Notable';
                };
                
                const standoutTypes = [
                    { type: 'king', count: 3, baseYear: -2300 },
                    { type: 'queen', count: 2, baseYear: -2300 },
                    { type: 'prince', count: 2, baseYear: -2250 },
                    { type: 'princess', count: 2, baseYear: -2250 },
                    { type: 'emperor', count: 1, baseYear: -2200 },
                    { type: 'empress', count: 1, baseYear: -2200 },
                    { type: 'founder', count: 4, baseYear: -2400 },
                    { type: 'general', count: 3, baseYear: -2350 },
                    { type: 'commander', count: 3, baseYear: -2300 },
                    { type: 'war_chief', count: 2, baseYear: -2250 },
                    { type: 'marshal', count: 2, baseYear: -2200 },
                    { type: 'admiral', count: 1, baseYear: -2150 },
                    { type: 'knight', count: 4, baseYear: -2400 },
                    { type: 'champion', count: 3, baseYear: -2350 },
                    { type: 'hero', count: 5, baseYear: -2500 },
                    { type: 'dragon_slayer', count: 2, baseYear: -2100 },
                    { type: 'giant_slayer', count: 1, baseYear: -2050 },
                    { type: 'demon_slayer', count: 1, baseYear: -2000 },
                    { type: 'monster_slayer', count: 2, baseYear: -1950 },
                    { type: 'savior', count: 3, baseYear: -2450 },
                    { type: 'protector', count: 2, baseYear: -2400 },
                    { type: 'guardian', count: 2, baseYear: -2350 },
                    { type: 'wizard', count: 4, baseYear: -2400 },
                    { type: 'archmage', count: 2, baseYear: -2350 },
                    { type: 'necromancer', count: 2, baseYear: -1900 },
                    { type: 'lich', count: 1, baseYear: -2150 },
                    { type: 'sorcerer', count: 2, baseYear: -2300 },
                    { type: 'warlock', count: 1, baseYear: -2250 },
                    { type: 'witch', count: 2, baseYear: -2200 },
                    { type: 'enchanter', count: 2, baseYear: -2150 },
                    { type: 'alchemist', count: 2, baseYear: -2100 },
                    { type: 'villain', count: 3, baseYear: -2450 },
                    { type: 'vampire', count: 1, baseYear: -2200 },
                    { type: 'high_priest', count: 2, baseYear: -2000 },
                    { type: 'oracle', count: 1, baseYear: -1850 },
                    { type: 'prophet', count: 2, baseYear: -1800 },
                ];
                
                world.standoutMortals = [];
                world.worldEvents = world.worldEvents || [];
                const usedNames = new Set();
                let standoutIndex = 0;
                
                standoutTypes.forEach(({ type, count, baseYear }) => {
                    for (let i = 0; i < count; i++) {
                        const standoutRng = new SeededRNG(seed + '-standout-' + type + '-' + i);
                        const race = world.mortalRaces[Math.floor(standoutRng.random() * world.mortalRaces.length)];
                        const raceName = race.name.replace(/^The /, '');
                        
                        // Select organization for birthplace
                        let organization = null;
                        let locationId = null;
                        if (world.organizations && world.organizations.length > 0) {
                            const raceOrgs = world.organizations.filter(o => o.race === race.id);
                            const orgsToChooseFrom = raceOrgs.length > 0 ? raceOrgs : world.organizations;
                            if (orgsToChooseFrom.length > 0) {
                                organization = standoutRng.choice(orgsToChooseFrom);
                                locationId = organization.location || null;
                            }
                        }
                        
                        // Fallback to geography
                        if (!locationId && world.geography.length > 0) {
                            const geo = world.geography[Math.floor(standoutRng.random() * world.geography.length)];
                            locationId = geo.id;
                        }
                        
                        // Generate name with proper race-based names and titles
                        const raceNames = getRaceNames(raceName);
                        const firstName = standoutRng.choice(raceNames.firstNames);
                        const lastName = standoutRng.choice(raceNames.lastNames);
                        const title = getTitleForType(type);
                        let locationSuffix = '';
                        if (organization?.name) {
                            locationSuffix = ` of ${organization.name}`;
                        } else if (locationId) {
                            const location = world.geography.find(g => g.id === locationId);
                            if (location) {
                                locationSuffix = ` of ${location.name}`;
                            }
                        }
                        let name = `${title} ${firstName} ${lastName}${locationSuffix}`;
                        // Ensure uniqueness
                        let attempts = 0;
                        while (usedNames.has(name) && attempts < 100) {
                            const altLastName = standoutRng.choice(raceNames.lastNames);
                            name = `${title} ${firstName} ${altLastName}${locationSuffix}`;
                            attempts++;
                        }
                        usedNames.add(name);
                        
                        // Generate alignment
                        const alignments = {
                            king: standoutRng.random() > 0.5 ? 'good' : 'neutral',
                            queen: standoutRng.random() > 0.5 ? 'good' : 'neutral',
                            prince: standoutRng.random() > 0.5 ? 'good' : 'neutral',
                            princess: standoutRng.random() > 0.5 ? 'good' : 'neutral',
                            emperor: standoutRng.random() > 0.7 ? 'good' : standoutRng.random() > 0.3 ? 'neutral' : 'evil',
                            empress: standoutRng.random() > 0.7 ? 'good' : standoutRng.random() > 0.3 ? 'neutral' : 'evil',
                            founder: standoutRng.random() > 0.6 ? 'good' : 'neutral',
                            general: standoutRng.random() > 0.7 ? 'good' : standoutRng.random() > 0.3 ? 'neutral' : 'evil',
                            commander: standoutRng.random() > 0.6 ? 'good' : 'neutral',
                            war_chief: standoutRng.random() > 0.5 ? 'neutral' : 'evil',
                            marshal: standoutRng.random() > 0.6 ? 'good' : 'neutral',
                            admiral: standoutRng.random() > 0.6 ? 'good' : 'neutral',
                            knight: 'good', champion: 'good', hero: 'good',
                            dragon_slayer: 'good', giant_slayer: 'good', demon_slayer: 'good', monster_slayer: 'good',
                            savior: 'good', protector: 'good', guardian: 'good',
                            wizard: 'neutral', archmage: 'neutral',
                            necromancer: 'evil', lich: 'evil',
                            sorcerer: standoutRng.random() > 0.5 ? 'neutral' : 'evil',
                            warlock: 'evil',
                            witch: standoutRng.random() > 0.5 ? 'neutral' : 'evil',
                            enchanter: 'neutral', alchemist: 'neutral',
                            villain: 'evil', vampire: 'evil',
                            high_priest: 'good', oracle: 'neutral', prophet: 'good',
                        };
                        const alignment = alignments[type] || 'neutral';
                        
                        // Generate description
                        const orgName = organization?.name || 'their homeland';
                        const descriptions = {
                            king: `${name} is a king of the ${raceName}, born in ${orgName} and ruler of their people.`,
                            queen: `${name} is a queen of the ${raceName}, born in ${orgName} and ruler of their people.`,
                            prince: `${name} is a prince of the ${raceName}, born in ${orgName} and heir to the throne.`,
                            princess: `${name} is a princess of the ${raceName}, born in ${orgName} and heir to the throne.`,
                            emperor: `${name} is an emperor of the ${raceName}, born in ${orgName} and ruler of vast territories.`,
                            empress: `${name} is an empress of the ${raceName}, born in ${orgName} and ruler of vast territories.`,
                            founder: `${name} is the founder of ${orgName}, establishing the organization and shaping its destiny.`,
                            general: `${name} is a general of the ${raceName}, born in ${orgName} and master of military strategy.`,
                            commander: `${name} is a commander of the ${raceName}, born in ${orgName} and leader of warriors.`,
                            war_chief: `${name} is a war-chief of the ${raceName}, born in ${orgName} and leader of their warriors.`,
                            marshal: `${name} is a marshal of the ${raceName}, born in ${orgName} and organizer of military forces.`,
                            admiral: `${name} is an admiral of the ${raceName}, born in ${orgName} and master of naval warfare.`,
                            knight: `${name} is a knight of the ${raceName}, born in ${orgName} and renowned for their valor in battle.`,
                            champion: `${name} is a champion of the ${raceName}, born in ${orgName} and victor of many battles.`,
                            hero: `${name} is a legendary hero of the ${raceName}, born in ${orgName} and renowned for their courage and deeds.`,
                            dragon_slayer: `${name} is a dragon slayer of the ${raceName}, born in ${orgName} and slayer of great wyrms.`,
                            giant_slayer: `${name} is a giant slayer of the ${raceName}, born in ${orgName} and slayer of colossal foes.`,
                            demon_slayer: `${name} is a demon slayer of the ${raceName}, born in ${orgName} and banisher of infernal beings.`,
                            monster_slayer: `${name} is a monster slayer of the ${raceName}, born in ${orgName} and hunter of terrible beasts.`,
                            savior: `${name} is a savior of the ${raceName}, born in ${orgName} and rescuer in dire circumstances.`,
                            protector: `${name} is a protector of the ${raceName}, born in ${orgName} and defender of the innocent.`,
                            guardian: `${name} is a guardian of the ${raceName}, born in ${orgName} and watcher over sacred places.`,
                            wizard: `${name} is a powerful wizard of the ${raceName}, born in ${orgName} and master of the arcane arts.`,
                            archmage: `${name} is an archmage of the ${raceName}, born in ${orgName} and one of the greatest magical practitioners.`,
                            necromancer: `${name} is a necromancer of the ${raceName}, practicing dark arts in ${orgName} and master of the undead.`,
                            lich: `${name} is a powerful lich of the ${raceName}, achieving undeath in ${orgName} and master of death magic.`,
                            sorcerer: `${name} is a sorcerer of the ${raceName}, born in ${orgName} with innate magical power.`,
                            warlock: `${name} is a warlock of the ${raceName}, born in ${orgName} and wielder of forbidden magic.`,
                            witch: `${name} is a witch of the ${raceName}, born in ${orgName} and practitioner of ancient magic.`,
                            enchanter: `${name} is an enchanter of the ${raceName}, born in ${orgName} and master of magical enhancement.`,
                            alchemist: `${name} is an alchemist of the ${raceName}, born in ${orgName} and master of transformation.`,
                            villain: `${name} is a feared villain of the ${raceName}, born in ${orgName} and known for their dark deeds.`,
                            vampire: `${name} is an immortal vampire of the ${raceName}, transformed in ${orgName} and terror of the night.`,
                            high_priest: `${name} is a high priest of the ${raceName}, serving the divine in ${orgName} with unwavering faith.`,
                            oracle: `${name} is an oracle of the ${raceName}, seeing the future from ${orgName} and guide to destiny.`,
                            prophet: `${name} is a prophet of the ${raceName}, speaking divine words from ${orgName} and voice of the gods.`,
                        };
                        const description = descriptions[type] || `${name} is a notable ${type} of the ${raceName}, born in ${orgName}.`;
                        
                        const standout = {
                            id: `standout-${type}-${standoutIndex}`,
                            type: 'standout_mortal',
                            standoutType: type,
                            name,
                            description,
                            parentId: race.id,
                            race: race.id,
                            organization: organization ? organization.id : undefined,
                            location: locationId || 'unknown',
                            alignment,
                            isBoss: alignment === 'evil',
                            age: standoutRng.range(30, 100),
                            powers: ['Combat Expertise', 'Leadership'], // Simplified for HTML tool
                        };
                        
                        world.standoutMortals.push(standout);
                        standoutIndex++;
                        
                        // Create world event for necromancers building towers
                        if (type === 'necromancer' && locationId) {
                            world.worldEvents.push({
                                type: 'built_tower',
                                entityId: standout.id,
                                locationId: locationId,
                                description: `${name} built a tower for study and experimentation. The tower's construction is magical in nature and radiates a feeling of corruption and dread in great distances around it.`,
                                year: baseYear - (i * 30),
                                metadata: { purpose: 'necromantic research', standoutType: type },
                            });
                        }
                    }
                });
            }
            
            // Level 7.5: Dungeons
            if (levels.includes(7.5)) {
                world.dungeons = generateDungeons(world, seed, rng);
            }

            return world;
        }

        /**
         * Build provenance chain for an entity
         * Shows the creation hierarchy from root to current entity
         */
        function buildProvenanceChain(entityId, world) {
            const chain = [];
            let currentId = entityId;

            // Helper to find entity by ID
            function findEntity(id) {
                if (world.primordials) {
                    const found = world.primordials.find(p => p.id === id);
                    if (found) return { entity: found, type: 'primordial' };
                }
                if (world.cosmicCreators) {
                    const found = world.cosmicCreators.find(c => c.id === id);
                    if (found) return { entity: found, type: 'cosmic_creator' };
                }
                if (world.geography) {
                    const found = world.geography.find(g => g.id === id);
                    if (found) return { entity: found, type: 'geography' };
                }
                if (world.mortalRaces) {
                    const found = world.mortalRaces.find(r => r.id === id);
                    if (found) return { entity: found, type: 'mortal_race' };
                }
                if (world.conceptualBeings) {
                    const found = world.conceptualBeings.find(c => c.id === id);
                    if (found) return { entity: found, type: 'conceptual' };
                }
                if (world.organizations) {
                    const found = world.organizations.find(o => o.id === id);
                    if (found) return { entity: found, type: 'organization' };
                }
                if (world.demiGods) {
                    const found = world.demiGods.find(d => d.id === id);
                    if (found) return { entity: found, type: 'demigod' };
                }
                if (world.standoutMortals) {
                    const found = world.standoutMortals.find(s => s.id === id);
                    if (found) return { entity: found, type: 'standout_mortal' };
                }
                return null;
            }

            // Helper to format entity for display
            function formatEntity(entity, type) {
                let displayName = entity.name;
                let typeLabel = '';
                
                if (type === 'primordial') {
                    typeLabel = entity.primordialType || 'primordial';
                } else if (type === 'cosmic_creator') {
                    typeLabel = entity.element || 'cosmic creator';
                } else if (type === 'geography') {
                    typeLabel = (entity.geographyType || 'geography').replace(/_/g, ' ');
                } else if (type === 'mortal_race') {
                    // For races, just show the name, not redundant "Human (human)"
                    typeLabel = '';
                } else if (type === 'conceptual') {
                    typeLabel = (entity.conceptualType || 'conceptual').replace(/_/g, ' ');
                } else if (type === 'organization') {
                    typeLabel = entity.magnitude || 'organization';
                } else if (type === 'demigod') {
                    typeLabel = (entity.demiGodType || 'demigod').replace(/_/g, ' ');
                } else if (type === 'standout_mortal') {
                    typeLabel = (entity.standoutType || 'standout').replace(/_/g, ' ');
                } else if (type === 'family_lineage') {
                    typeLabel = 'family lineage';
                }
                
                return {
                    name: displayName,
                    typeLabel: typeLabel
                };
            }

            // Find the starting entity
            const startResult = findEntity(currentId);
            if (!startResult || !startResult.entity.parentId) return chain;

            // Build chain by walking up parentId references
            currentId = startResult.entity.parentId;
            while (currentId) {
                const result = findEntity(currentId);
                if (!result) break;

                const formatted = formatEntity(result.entity, result.type);
                chain.unshift({
                    id: currentId,
                    name: formatted.name,
                    typeLabel: formatted.typeLabel
                });

                currentId = result.entity.parentId;
            }

            return chain;
        }

        function displayWorld(world) {
            const resultsEl = document.getElementById('world-results');
            let html = '<div class="results-container">';
            html += `<h2 style="color: #ffd700; margin-bottom: 15px;">Generated World</h2>`;
            html += `<div style="color: #aaa; margin-bottom: 20px;">Seed: ${world.seed}</div>`;
            
            // Create expandable hierarchical tree view
            html += '<div class="tree-view">';
            
            // Level 1: Primordials
            if (world.primordials.length > 0) {
                const levelId = 'tree-level-1';
                html += `<div class="tree-node">`;
                html += `<span class="tree-toggle" data-level-id="${levelId}">Γû╝</span>`;
                html += `<strong style="color: #ffd700;">Level 1: Primordials</strong> <span style="color: #aaa;">(${world.primordials.length})</span>`;
                html += `<div class="tree-children expanded" id="${levelId}">`;
                world.primordials.forEach(p => {
                    const provenanceChain = buildProvenanceChain(p.id, world);
                    let provenanceHtml = '';
                    if (provenanceChain.length > 0) {
                        provenanceHtml = `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #16213e; font-size: 0.85em;">`;
                        provenanceHtml += `<div style="color: #ffd700; font-weight: bold; margin-bottom: 3px;">Provenance Chain:</div>`;
                        provenanceChain.forEach((link, index) => {
                            const arrow = index < provenanceChain.length - 1 ? ' ΓåÆ ' : '';
                            const typeDisplay = link.typeLabel ? ` (${link.typeLabel})` : '';
                            provenanceHtml += `<span style="color: #aaa;">${link.name}${typeDisplay}${arrow}</span>`;
                        });
                        provenanceHtml += `</div>`;
                    }
                    html += `<div class="entity-card" style="margin: 5px 0;"><div class="entity-name">${p.name}</div><div class="entity-type">${p.primordialType}</div><div class="entity-description">${p.description}</div>${provenanceHtml}</div>`;
                });
                html += '</div></div>';
            }
            
            // Level 2: Cosmic Creators
            if (world.cosmicCreators.length > 0) {
                const levelId = 'tree-level-2';
                html += `<div class="tree-node">`;
                html += `<span class="tree-toggle" data-level-id="${levelId}">Γû╝</span>`;
                html += `<strong style="color: #ffd700;">Level 2: Cosmic Creators</strong> <span style="color: #aaa;">(${world.cosmicCreators.length})</span>`;
                html += `<div class="tree-children expanded" id="${levelId}">`;
                world.cosmicCreators.forEach(c => {
                    const provenanceChain = buildProvenanceChain(c.id, world);
                    let provenanceHtml = '';
                    if (provenanceChain.length > 0) {
                        provenanceHtml = `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #16213e; font-size: 0.85em;">`;
                        provenanceHtml += `<div style="color: #ffd700; font-weight: bold; margin-bottom: 3px;">Provenance Chain:</div>`;
                        provenanceChain.forEach((link, index) => {
                            const arrow = index < provenanceChain.length - 1 ? ' ΓåÆ ' : '';
                            const typeDisplay = link.typeLabel ? ` (${link.typeLabel})` : '';
                            provenanceHtml += `<span style="color: #aaa;">${link.name}${typeDisplay}${arrow}</span>`;
                        });
                        provenanceHtml += `</div>`;
                    }
                    html += `<div class="entity-card" style="margin: 5px 0;"><div class="entity-name">${c.name}</div><div class="entity-type">${c.element}</div><div class="entity-description">${c.description}</div>${provenanceHtml}</div>`;
                });
                html += '</div></div>';
            }
            
            // Level 2.5: Geography
            if (world.geography.length > 0) {
                const levelId = 'tree-level-2.5';
                html += `<div class="tree-node">`;
                html += `<span class="tree-toggle" data-level-id="${levelId}">Γû╝</span>`;
                html += `<strong style="color: #ffd700;">Level 2.5: Geography</strong> <span style="color: #aaa;">(${world.geography.length})</span>`;
                html += `<div class="tree-children expanded" id="${levelId}">`;
                world.geography.forEach(g => {
                    const provenanceChain = buildProvenanceChain(g.id, world);
                    let provenanceHtml = '';
                    if (provenanceChain.length > 0) {
                        provenanceHtml = `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #16213e; font-size: 0.85em;">`;
                        provenanceHtml += `<div style="color: #ffd700; font-weight: bold; margin-bottom: 3px;">Provenance Chain:</div>`;
                        provenanceChain.forEach((link, index) => {
                            const arrow = index < provenanceChain.length - 1 ? ' ΓåÆ ' : '';
                            const typeDisplay = link.typeLabel ? ` (${link.typeLabel})` : '';
                            provenanceHtml += `<span style="color: #aaa;">${link.name}${typeDisplay}${arrow}</span>`;
                        });
                        provenanceHtml += `</div>`;
                    }
                    html += `<div class="entity-card" style="margin: 5px 0;"><div class="entity-name">${g.name}</div><div class="entity-type">${g.geographyType}</div><div class="entity-description">${g.description}</div>${provenanceHtml}</div>`;
                });
                html += '</div></div>';
            }
            
            // Level 3: Conceptual Beings
            if (world.conceptualBeings && world.conceptualBeings.length > 0) {
                const levelId = 'tree-level-3';
                html += `<div class="tree-node">`;
                html += `<span class="tree-toggle" data-level-id="${levelId}">Γû╝</span>`;
                html += `<strong style="color: #ffd700;">Level 3: Conceptual Beings</strong> <span style="color: #aaa;">(${world.conceptualBeings.length})</span>`;
                html += `<div class="tree-children expanded" id="${levelId}">`;
                world.conceptualBeings.forEach(being => {
                    const provenanceChain = buildProvenanceChain(being.id, world);
                    let provenanceHtml = '';
                    if (provenanceChain.length > 0) {
                        provenanceHtml = `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #16213e; font-size: 0.85em;">`;
                        provenanceHtml += `<div style="color: #ffd700; font-weight: bold; margin-bottom: 3px;">Provenance Chain:</div>`;
                        provenanceChain.forEach((link, index) => {
                            const arrow = index < provenanceChain.length - 1 ? ' ΓåÆ ' : '';
                            const typeDisplay = link.typeLabel ? ` (${link.typeLabel})` : '';
                            provenanceHtml += `<span style="color: #aaa;">${link.name}${typeDisplay}${arrow}</span>`;
                        });
                        provenanceHtml += `</div>`;
                    }
                    html += `<div class="entity-card" style="margin: 5px 0;"><div class="entity-name">${being.name}</div><div class="entity-type">${being.conceptualType}</div><div class="entity-description">${being.description}</div>${provenanceHtml}</div>`;
                });
                html += '</div></div>';
            }
            
            // Level 4: Demi-Gods
            if (world.demiGods && world.demiGods.length > 0) {
                const levelId = 'tree-level-4';
                html += `<div class="tree-node">`;
                html += `<span class="tree-toggle" data-level-id="${levelId}">Γû╝</span>`;
                html += `<strong style="color: #ffd700;">Level 4: Demi-Gods</strong> <span style="color: #aaa;">(${world.demiGods.length})</span>`;
                html += `<div class="tree-children expanded" id="${levelId}">`;
                world.demiGods.forEach(demiGod => {
                    const alignmentColor = demiGod.alignment === 'good' ? '#1eff00' : demiGod.alignment === 'evil' ? '#ff4444' : '#ffd700';
                    const provenanceChain = buildProvenanceChain(demiGod.id, world);
                    let provenanceHtml = '';
                    if (provenanceChain.length > 0) {
                        provenanceHtml = `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #16213e; font-size: 0.85em;">`;
                        provenanceHtml += `<div style="color: #ffd700; font-weight: bold; margin-bottom: 3px;">Provenance Chain:</div>`;
                        provenanceChain.forEach((link, index) => {
                            const arrow = index < provenanceChain.length - 1 ? ' ΓåÆ ' : '';
                            const typeDisplay = link.typeLabel ? ` (${link.typeLabel})` : '';
                            provenanceHtml += `<span style="color: #aaa;">${link.name}${typeDisplay}${arrow}</span>`;
                        });
                        provenanceHtml += `</div>`;
                    }
                    html += `<div class="entity-card" style="margin: 5px 0;">`;
                    html += `<div class="entity-name">${demiGod.name}</div>`;
                    html += `<div class="entity-type">${demiGod.demiGodType.replace(/_/g, ' ')}</div>`;
                    html += `<div class="entity-description">${demiGod.description}</div>`;
                    if (demiGod.powers && demiGod.powers.length > 0) {
                        html += `<div style="margin-top: 5px; color: #aaa;">Powers: ${demiGod.powers.join(', ')}</div>`;
                    }
                    html += `<div style="margin-top: 5px; color: #aaa;">Age: ${demiGod.age.toLocaleString()} years | Alignment: <span style="color: ${alignmentColor};">${demiGod.alignment || 'neutral'}</span></div>`;
                    if (demiGod.isBoss) {
                        html += `<div style="margin-top: 5px; color: #a335ee; font-weight: bold;">Can be used as dungeon boss</div>`;
                    }
                    html += `${provenanceHtml}</div>`;
                });
                html += '</div></div>';
            }
            
            // Level 5: Mortal Races
            if (world.mortalRaces && world.mortalRaces.length > 0) {
                const levelId = 'tree-level-5';
                html += `<div class="tree-node">`;
                html += `<span class="tree-toggle" data-level-id="${levelId}">Γû╝</span>`;
                html += `<strong style="color: #ffd700;">Level 5: Mortal Races</strong> <span style="color: #aaa;">(${world.mortalRaces.length})</span>`;
                html += `<div class="tree-children expanded" id="${levelId}">`;
                world.mortalRaces.forEach(race => {
                    const provenanceChain = buildProvenanceChain(race.id, world);
                    let provenanceHtml = '';
                    if (provenanceChain.length > 0) {
                        provenanceHtml = `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #16213e; font-size: 0.85em;">`;
                        provenanceHtml += `<div style="color: #ffd700; font-weight: bold; margin-bottom: 3px;">Provenance Chain:</div>`;
                        provenanceChain.forEach((link, index) => {
                            const arrow = index < provenanceChain.length - 1 ? ' ΓåÆ ' : '';
                            const typeDisplay = link.typeLabel ? ` (${link.typeLabel})` : '';
                            provenanceHtml += `<span style="color: #aaa;">${link.name}${typeDisplay}${arrow}</span>`;
                        });
                        provenanceHtml += `</div>`;
                    }
                    html += `<div class="entity-card" style="margin: 5px 0;"><div class="entity-name">${race.name}</div><div class="entity-type">${race.raceType}</div><div class="entity-description">${race.description}</div>${provenanceHtml}</div>`;
                });
                html += '</div></div>';
            }
            
            // Level 6: Organizations
            if (world.organizations && world.organizations.length > 0) {
                const levelId = 'tree-level-6';
                html += `<div class="tree-node">`;
                html += `<span class="tree-toggle" data-level-id="${levelId}">Γû╝</span>`;
                html += `<strong style="color: #ffd700;">Level 6: Organizations</strong> <span style="color: #aaa;">(${world.organizations.length})</span>`;
                html += `<div class="tree-children expanded" id="${levelId}">`;
                world.organizations.forEach(org => {
                    const provenanceChain = buildProvenanceChain(org.id, world);
                    let provenanceHtml = '';
                    if (provenanceChain.length > 0) {
                        provenanceHtml = `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #16213e; font-size: 0.85em;">`;
                        provenanceHtml += `<div style="color: #ffd700; font-weight: bold; margin-bottom: 3px;">Provenance Chain:</div>`;
                        provenanceChain.forEach((link, index) => {
                            const arrow = index < provenanceChain.length - 1 ? ' ΓåÆ ' : '';
                            const typeDisplay = link.typeLabel ? ` (${link.typeLabel})` : '';
                            provenanceHtml += `<span style="color: #aaa;">${link.name}${typeDisplay}${arrow}</span>`;
                        });
                        provenanceHtml += `</div>`;
                    }
                    html += `<div class="entity-card" style="margin: 5px 0;"><div class="entity-name">${org.name}</div><div class="entity-type">${org.magnitude}</div><div class="entity-description">${org.description}</div><div style="margin-top: 5px; color: #aaa;">Members: ${org.members}</div>${provenanceHtml}</div>`;
                });
                html += '</div></div>';
            }
            
            // Level 6.5: Standout Mortals
            if (world.standoutMortals && world.standoutMortals.length > 0) {
                const levelId = 'tree-level-6.5';
                html += `<div class="tree-node">`;
                html += `<span class="tree-toggle" data-level-id="${levelId}">Γû╝</span>`;
                html += `<strong style="color: #ffd700;">Level 6.5: Standout Mortals</strong> <span style="color: #aaa;">(${world.standoutMortals.length})</span>`;
                html += `<div class="tree-children expanded" id="${levelId}">`;
                world.standoutMortals.forEach(standout => {
                    const alignmentColor = standout.alignment === 'good' ? '#1eff00' : standout.alignment === 'evil' ? '#ff4444' : '#ffd700';
                    const provenanceChain = buildProvenanceChain(standout.id, world);
                    let provenanceHtml = '';
                    if (provenanceChain.length > 0) {
                        provenanceHtml = `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #16213e; font-size: 0.85em;">`;
                        provenanceHtml += `<div style="color: #ffd700; font-weight: bold; margin-bottom: 3px;">Provenance Chain:</div>`;
                        provenanceChain.forEach((link, index) => {
                            const arrow = index < provenanceChain.length - 1 ? ' ΓåÆ ' : '';
                            const typeDisplay = link.typeLabel ? ` (${link.typeLabel})` : '';
                            provenanceHtml += `<span style="color: #aaa;">${link.name}${typeDisplay}${arrow}</span>`;
                        });
                        provenanceHtml += `</div>`;
                    }
                    html += `<div class="entity-card" style="margin: 5px 0;">`;
                    html += `<div class="entity-name">${standout.name}</div>`;
                    html += `<div class="entity-type">${standout.standoutType.replace(/_/g, ' ')}</div>`;
                    html += `<div class="entity-description">${standout.description}</div>`;
                    html += `<div style="margin-top: 5px; color: #aaa;">Alignment: <span style="color: ${alignmentColor};">${standout.alignment}</span> | Age: ${standout.age}</div>`;
                    if (standout.isBoss) {
                        html += `<div style="margin-top: 5px; color: #a335ee; font-weight: bold;">Can be used as dungeon boss</div>`;
                    }
                    html += `${provenanceHtml}</div>`;
                });
                html += '</div></div>';
            }
            
            // Level 7.5: Dungeons
            if (world.dungeons && world.dungeons.length > 0) {
                const levelId = 'tree-level-7.5';
                html += `<div class="tree-node">`;
                html += `<span class="tree-toggle" data-level-id="${levelId}">Γû╝</span>`;
                html += `<strong style="color: #ffd700;">Level 7.5: Dungeons</strong> <span style="color: #aaa;">(${world.dungeons.length})</span>`;
                html += `<div class="tree-children expanded" id="${levelId}">`;
                world.dungeons.forEach(dungeon => {
                    // Build provenance chain from the creator (since dungeons are created entities)
                    let provenanceChain = [];
                    let creatorInfo = '';
                    
                    if (dungeon.createdBy === 'organization') {
                        const creator = world.organizations?.find(o => o.id === dungeon.creatorId);
                        if (creator) {
                            provenanceChain = buildProvenanceChain(creator.id, world);
                            creatorInfo = `<div style="margin-top: 5px; color: #aaa;">Created by Organization: <span style="color: #fff;">${creator.name}</span> (${creator.magnitude})</div>`;
                        }
                    } else if (dungeon.createdBy === 'standout_mortal') {
                        const creator = world.standoutMortals?.find(m => m.id === dungeon.creatorId);
                        if (creator) {
                            provenanceChain = buildProvenanceChain(creator.id, world);
                            creatorInfo = `<div style="margin-top: 5px; color: #aaa;">Created by: <span style="color: #fff;">${creator.name}</span> (${creator.standoutType.replace(/_/g, ' ')})</div>`;
                        }
                    }
                    
                    let provenanceHtml = '';
                    if (provenanceChain.length > 0) {
                        provenanceHtml = `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #16213e; font-size: 0.85em;">`;
                        provenanceHtml += `<div style="color: #ffd700; font-weight: bold; margin-bottom: 3px;">Creator's Provenance:</div>`;
                        provenanceChain.forEach((link, index) => {
                            const arrow = index < provenanceChain.length - 1 ? ' ΓåÆ ' : '';
                            const typeDisplay = link.typeLabel ? ` (${link.typeLabel})` : '';
                            provenanceHtml += `<span style="color: #aaa;">${link.name}${typeDisplay}${arrow}</span>`;
                        });
                        provenanceHtml += `</div>`;
                    }
                    
                    // Location information
                    let locationInfo = '';
                    const location = world.geography?.find(g => g.id === dungeon.location);
                    if (location) {
                        locationInfo = `<div style="margin-top: 5px; color: #aaa;">Location: <span style="color: #fff;">${location.name}</span> (${location.geographyType.replace(/_/g, ' ')})</div>`;
                    }
                    
                    html += `<div class="entity-card" style="margin: 5px 0;">`;
                    html += `<div class="entity-name">${dungeon.name}</div>`;
                    html += `<div class="entity-type">${dungeon.dungeonType}</div>`;
                    html += `<div class="entity-description">${dungeon.description}</div>`;
                    html += `<div style="margin-top: 5px; color: #aaa;">Purpose: <span style="color: #fff;">${dungeon.purpose}</span> | Age: <span style="color: #fff;">${Math.abs(dungeon.age)} years ago</span> | Depth: <span style="color: #fff;">${dungeon.depth} levels</span></div>`;
                    html += creatorInfo;
                    html += locationInfo;
                    html += `${provenanceHtml}</div>`;
                });
                html += '</div></div>';
            }
            
            html += '</div>'; // Close tree-view
            html += '</div>'; // Close results-container
            resultsEl.innerHTML = html;
            
            // Attach click handlers directly to toggle buttons after HTML is inserted
            resultsEl.querySelectorAll('.tree-toggle').forEach(toggle => {
                const levelId = toggle.getAttribute('data-level-id');
                if (levelId) {
                    // Remove any existing handlers
                    toggle.onclick = null;
                    // Add new click handler
                    toggle.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        if (window.toggleTreeLevel) {
                            window.toggleTreeLevel(levelId);
                        } else {
                            console.error('toggleTreeLevel function not found!');
                        }
                        return false;
                    });
                }
            });
        }

        // ============================================================================
        // DUNGEON GENERATION SYSTEM (Integrated with World Generation)
        // ============================================================================

        function generateDungeons(world, seed, rng) {
            const dungeons = [];
            
            if ((!world.organizations || world.organizations.length === 0) && 
                (!world.standoutMortals || world.standoutMortals.length === 0)) {
                return dungeons;
            }
            
            if (!world.geography || world.geography.length === 0) {
                return dungeons;
            }
            
            // Generate dungeons from organizations
            if (world.organizations) {
                world.organizations.forEach(org => {
                    if (shouldOrganizationCreateDungeon(org, rng)) {
                        const dungeon = generateDungeonFromOrganization(org, world, seed, rng);
                        if (dungeon) {
                            dungeons.push(dungeon);
                        }
                    }
                });
            }
            
            // Generate dungeons from standout mortals
            if (world.standoutMortals) {
                world.standoutMortals.forEach(mortal => {
                    if (shouldMortalCreateDungeon(mortal)) {
                        const dungeon = generateDungeonFromMortal(mortal, world, seed, rng);
                        if (dungeon) {
                            dungeons.push(dungeon);
                        }
                    }
                });
            }
            
            // Assign bosses to dungeons (Rules 2 & 3)
            assignBossesToDungeons(dungeons, world, seed, rng);
            
            return dungeons;
        }
        
        function assignBossesToDungeons(dungeons, world, seed, rng) {
            // Find available evil entities for boss assignment
            const availableEvilDemigods = (world.demiGods || []).filter(
                d => d.alignment === 'evil' && d.isBoss
            );
            
            const availableEvilMortals = (world.standoutMortals || []).filter(
                m => m.alignment === 'evil' && m.isBoss
            );
            
            // Get IDs of mortals that already created dungeons (they're already final bosses)
            const dungeonCreatorIds = new Set(
                dungeons
                    .filter(d => d.createdBy === 'standout_mortal')
                    .map(d => d.creatorId)
            );
            
            // Filter out mortals that already created dungeons
            const assignableEvilMortals = availableEvilMortals.filter(
                m => !dungeonCreatorIds.has(m.id)
            );
            
            // Rule 2: Assign evil entities to dungeons without final bosses
            for (const dungeon of dungeons) {
                // Skip if dungeon already has a final boss (Rule 1 - creator is boss)
                if (dungeon.finalBoss) {
                    continue;
                }
                
                // Try to assign an evil demi-god or mortal as final boss
                let assigned = false;
                
                // Prefer demi-gods for more powerful dungeons
                if (availableEvilDemigods.length > 0 && rng.random() < 0.6) {
                    const index = rng.range(0, availableEvilDemigods.length - 1);
                    const demigod = availableEvilDemigods.splice(index, 1)[0];
                    
                    dungeon.finalBoss = {
                        level: dungeon.depth,
                        bossId: demigod.id,
                        bossType: 'demigod',
                        bossName: demigod.name,
                        bossAlignment: demigod.alignment,
                    };
                    assigned = true;
                } else if (assignableEvilMortals.length > 0) {
                    const index = rng.range(0, assignableEvilMortals.length - 1);
                    const mortal = assignableEvilMortals.splice(index, 1)[0];
                    
                    dungeon.finalBoss = {
                        level: dungeon.depth,
                        bossId: mortal.id,
                        bossType: 'standout_mortal',
                        bossName: mortal.name,
                        bossRace: mortal.race,
                        bossAlignment: mortal.alignment,
                    };
                    assigned = true;
                }
                
                // Rule 3: If no evil entity available, generate proc-gen boss
                if (!assigned) {
                    dungeon.finalBoss = generateProcGenBoss(dungeon, 'final', world, rng);
                }
            }
            
            // Assign mid-bosses to ALL dungeons (including those with final bosses)
            for (const dungeon of dungeons) {
                dungeon.midBosses = assignMidBosses(dungeon, world, rng);
            }
        }
        
        function assignMidBosses(dungeon, world, rng) {
            const midBosses = [];
            const midBossLevels = [];
            
            // Determine mid-boss levels (every 25 levels, excluding final)
            for (let level = 25; level < dungeon.depth; level += 25) {
                midBossLevels.push(level);
            }
            
            // Find available evil entities for mid-bosses (only standout mortals, no demi-gods)
            const availableEvilMortals = (world.standoutMortals || []).filter(
                m => m.alignment === 'evil' && m.isBoss
            );

            // Get IDs already used as final bosses
            const usedBossIds = new Set();
            if (dungeon.finalBoss) {
                usedBossIds.add(dungeon.finalBoss.bossId);
            }

            // Assign bosses to mid-boss levels
            for (const level of midBossLevels) {
                // Try to assign an evil standout mortal (30% chance per level)
                let assigned = false;
                
                if (rng.random() < 0.3 && availableEvilMortals.length > 0) {
                    const mortal = availableEvilMortals.find(
                        m => !usedBossIds.has(m.id) && m.id !== dungeon.creatorId
                    );
                    if (mortal) {
                        usedBossIds.add(mortal.id);
                        midBosses.push({
                            level: level,
                            bossId: mortal.id,
                            bossType: 'standout_mortal',
                            bossName: mortal.name,
                            bossRace: mortal.race,
                            bossAlignment: mortal.alignment,
                        });
                        assigned = true;
                    }
                }
                
                // If no entity assigned, ALWAYS generate proc-gen mid-boss
                // This ensures every 25th level has a mid-boss
                if (!assigned) {
                    const procGenBoss = generateProcGenBoss(dungeon, 'mid', world, rng, level);
                    if (procGenBoss) {
                        midBosses.push(procGenBoss);
                    }
                }
            }
            
            return midBosses;
        }
        
        function generateProcGenBoss(dungeon, type, world, rng, level) {
            const bossLevel = type === 'final' ? dungeon.depth : (level || 25);
            const bossSeed = `${dungeon.seed}-boss-${type}-${bossLevel}`;
            
            // Determine boss theme based on dungeon
            const bossTypes = [];
            
            // If dungeon has a creator with race/type info, theme accordingly
            if (dungeon.createdBy === 'organization') {
                const org = (world.organizations || []).find(o => o.id === dungeon.creatorId);
                if (org) {
                    // Get race name from race ID
                    const raceName = getRaceNameFromId(org.race, world);
                    if (raceName) {
                        const bossTypeSuffix = getBossTypeForRace(raceName, rng);
                        bossTypes.push(`${raceName} ${bossTypeSuffix}`);
                    }
                }
            }
            // Note: standout_mortal creators are already the final boss, so no fallback needed
            
            // Fallback boss types
            if (bossTypes.length === 0) {
                bossTypes.push(
                    'Orc War-Chief',
                    'Lich',
                    'Necromancer',
                    'Dragon',
                    'Troll King',
                    'Giant',
                    'Demon',
                    'Undead Lord'
                );
            }
            
            // Use seeded selection for deterministic generation
            const seedRng = new SeededRNG(bossSeed);
            const bossType = bossTypes[seedRng.range(0, bossTypes.length - 1)];
            const bossName = generateProcGenBossName(bossType, bossSeed);
            
            // Determine race/alignment from boss type
            let bossRace;
            let bossAlignment = 'evil';
            
            if (bossType.includes('Orc')) {
                bossRace = 'Orc';
            } else if (bossType.includes('Lich') || bossType.includes('Necromancer') || bossType.includes('Undead')) {
                bossAlignment = 'evil';
            }
            
            return {
                level: bossLevel,
                bossId: `procgen-boss-${bossSeed}`,
                bossType: 'procgen',
                bossName: bossName,
                bossRace: bossRace,
                bossAlignment: bossAlignment,
            };
        }
        
        function getRaceNameFromId(raceId, world) {
            // Look up the race in mortalRaces
            const race = (world.mortalRaces || []).find(r => r.id === raceId);
            if (race) {
                // Return the race name (without "The" prefix if present)
                return race.name.replace(/^The /, '');
            }
            
            // Fallback: try to extract race name from ID format (e.g., "race-orc-6" -> "Orc")
            if (raceId.startsWith('race-')) {
                const parts = raceId.split('-');
                if (parts.length >= 2) {
                    const raceType = parts[1];
                    // Capitalize first letter
                    return raceType.charAt(0).toUpperCase() + raceType.slice(1);
                }
            }
            
            return null;
        }
        
        function getBossTypeForRace(raceName, rng) {
            const raceBossTypes = {
                'Orc': ['War-Chief', 'Warlord', 'Brute', 'Berserker'],
                'Goblin': ['Chieftain', 'King', 'Overlord'],
                'Human': ['Bandit Lord', 'Dark Knight', 'Cult Leader'],
                'Elf': ['Dark Elf', 'Corrupted Mage'],
                'Dwarf': ['King', 'Lord'],
            };
            
            const types = raceBossTypes[raceName] || ['Leader', 'Lord', 'King'];
            return types[rng.range(0, types.length - 1)];
        }
        
        function generateProcGenBossName(bossType, seed) {
            // Use a simple seeded hash for deterministic generation
            let hash = 0;
            for (let i = 0; i < seed.length; i++) {
                hash = ((hash << 5) - hash) + seed.charCodeAt(i);
                hash = hash & hash; // Convert to 32-bit integer
            }
            const prefixes = ['The', 'Lord', 'King', 'Master', 'General'];
            const prefix = prefixes[Math.abs(hash) % prefixes.length];
            return `${prefix} ${bossType}`;
        }
        
        function shouldOrganizationCreateDungeon(org, rng) {
            const dungeonLikelyTypes = ['kingdom', 'horde', 'realm', 'stronghold'];
            const isLikelyType = dungeonLikelyTypes.includes(org.magnitude);
            
            const dungeonPurposes = ['mining', 'fortress', 'citadel', 'stronghold', 'vault'];
            const hasDungeonPurpose = org.purpose && dungeonPurposes.some(p => 
                org.purpose.toLowerCase().includes(p)
            );
            
            let probability = 0.1;
            if (isLikelyType) probability = 0.3;
            if (hasDungeonPurpose) probability = 0.7;
            
            return rng.random() < probability;
        }
        
        function shouldMortalCreateDungeon(mortal) {
            const dungeonCreatorTypes = [
                'necromancer', 'wizard', 'archmage', 'lich', 'sorcerer', 
                'warlock', 'villain', 'vampire'
            ];
            return dungeonCreatorTypes.includes(mortal.standoutType);
        }
        
        function generateDungeonFromOrganization(org, world, seed, rng) {
            if (!org.location) return null;
            
            const dungeonType = determineDungeonType(org, world);
            const purpose = generateDungeonPurpose(org, rng);
            const age = generateDungeonAge(rng);
            const depth = generateDungeonDepth(rng);
            const name = generateDungeonName(org, dungeonType, rng);
            const description = `A ${dungeonType} built by ${org.name} as a ${purpose}.`;
            const dungeonSeed = `${seed}-dungeon-${org.id}`;
            
            return {
                id: `dungeon-org-${org.id}`,
                name,
                type: 'dungeon',
                dungeonType,
                location: org.location,
                createdBy: 'organization',
                creatorId: org.id,
                purpose,
                age,
                depth,
                seed: dungeonSeed,
                description,
                createdAt: new Date(),
                discoveredAt: new Date(),
                parentId: org.id,
                finalBoss: null, // Will be assigned in boss assignment phase
                midBosses: [], // Will be assigned in boss assignment phase
                metadata: {
                    organizationMagnitude: org.magnitude,
                    organizationRace: org.race,
                },
            };
        }
        
        function generateDungeonFromMortal(mortal, world, seed, rng) {
            let locationId;
            
            if (mortal.organization) {
                const org = world.organizations?.find(o => o.id === mortal.organization);
                if (org && org.location) {
                    locationId = org.location;
                }
            }
            
            if (!locationId) {
                if (world.geography && world.geography.length > 0) {
                    const index = rng.range(0, world.geography.length - 1);
                    locationId = world.geography[index].id;
                } else {
                    return null;
                }
            }
            
            const isTower = mortal.standoutType === 'necromancer' || 
                            mortal.standoutType === 'lich' ||
                            mortal.standoutType === 'wizard' ||
                            mortal.standoutType === 'archmage';
            const dungeonType = isTower ? 'tower' : 'dungeon';
            
            const purpose = generateDungeonPurposeForMortal(mortal, rng);
            const age = generateDungeonAge(rng);
            const depth = generateDungeonDepth(rng);
            const name = generateDungeonNameForMortal(mortal, dungeonType, rng);
            const description = `A ${dungeonType} built by ${mortal.name}, a ${mortal.standoutType.replace(/_/g, ' ')}, as a ${purpose}.`;
            const dungeonSeed = `${seed}-dungeon-${mortal.id}`;
            
            // Rule 1: If a standout mortal creates a dungeon, they ARE the final boss
            const finalBoss = {
                level: depth,
                bossId: mortal.id,
                bossType: 'standout_mortal',
                bossName: mortal.name,
                bossRace: mortal.race,
                bossAlignment: mortal.alignment,
            };
            
            return {
                id: `dungeon-mortal-${mortal.id}`,
                name,
                type: 'dungeon',
                dungeonType,
                location: locationId,
                createdBy: 'standout_mortal',
                creatorId: mortal.id,
                purpose,
                age,
                depth,
                seed: dungeonSeed,
                description,
                createdAt: new Date(),
                discoveredAt: new Date(),
                parentId: mortal.organization || mortal.location,
                finalBoss,
                midBosses: [], // Will be assigned in boss assignment phase
                metadata: {
                    mortalType: mortal.standoutType,
                    mortalRace: mortal.race,
                    mortalAlignment: mortal.alignment,
                },
            };
        }
        
        function determineDungeonType(org, world) {
            const towerOrganizations = ['necromancer_cult', 'wizard_guild'];
            if (org.purpose && towerOrganizations.some(t => org.purpose.toLowerCase().includes(t))) {
                return 'tower';
            }
            
            if (world.worldEvents) {
                const towerEvents = world.worldEvents.filter(e => 
                    e.type === 'built_tower' && e.locationId === org.location
                );
                if (towerEvents.length > 0) {
                    return 'tower';
                }
            }
            
            return 'dungeon';
        }
        
        function generateDungeonPurpose(org, rng) {
            const purposes = [
                'mining operation', 'fortress', 'vault', 'prison', 'temple',
                'laboratory', 'barracks', 'warehouse', 'citadel'
            ];
            
            if (org.purpose) {
                if (org.purpose.toLowerCase().includes('mining')) return 'mining operation';
                if (org.purpose.toLowerCase().includes('fortress') || 
                    org.purpose.toLowerCase().includes('stronghold')) {
                    return 'fortress';
                }
            }
            
            return rng.choice(purposes);
        }
        
        function generateDungeonPurposeForMortal(mortal, rng) {
            const typePurposes = {
                necromancer: ['necromantic research', 'tower of undeath', 'dark experiments'],
                lich: ['phylactery vault', 'undead sanctum', 'dark citadel'],
                wizard: ['magical research', 'spell library', 'arcane laboratory'],
                archmage: ['grand library', 'arcane tower', 'spell repository'],
                sorcerer: ['power focus', 'magical nexus'],
                warlock: ['pact sanctum', 'dark altar'],
                villain: ['hidden lair', 'secret base'],
                vampire: ['blood sanctum', 'underground crypt'],
            };
            
            const purposes = typePurposes[mortal.standoutType] || ['lair', 'sanctum'];
            return rng.choice(purposes);
        }
        
        function generateDungeonAge(rng) {
            const ages = [-50, -100, -200, -500, -1000, -2000];
            return rng.choice(ages);
        }
        
        function generateDungeonDepth(rng) {
            return rng.range(50, 100); // 50-100 levels
        }
        
        function generateDungeonName(org, dungeonType, rng) {
            const prefixes = ['Ancient', 'Forgotten', 'Dark', 'Cursed', 'Lost'];
            const suffixes = dungeonType === 'tower'
                ? ['Tower', 'Spire', 'Keep', 'Citadel', 'Fortress']
                : ['Caverns', 'Depths', 'Catacombs', 'Mines', 'Labyrinth'];
            
            if (rng.random() < 0.3) {
                return `${org.name}'s ${rng.choice(suffixes)}`;
            }
            
            return `${rng.choice(prefixes)} ${rng.choice(suffixes)}`;
        }
        
        function generateDungeonNameForMortal(mortal, dungeonType, rng) {
            if (dungeonType === 'tower' && rng.random() < 0.7) {
                return `${mortal.name}'s Tower`;
            }
            
            const prefixes = ['Dark', 'Forgotten', 'Ancient', 'Cursed'];
            const suffixes = dungeonType === 'tower'
                ? ['Tower', 'Spire', 'Keep']
                : ['Sanctum', 'Lair', 'Crypt'];
            
            return `${rng.choice(prefixes)} ${rng.choice(suffixes)}`;
        }

        // ============================================================================
        // DUNGEON REGISTRY VIEW
        // ============================================================================

        function viewDungeonRegistry() {
            const loadingEl = document.getElementById('dungeon-loading');
            const resultsEl = document.getElementById('dungeon-results');
            
            loadingEl.classList.add('active');
            resultsEl.innerHTML = '';
            
            setTimeout(() => {
                const world = sharedContext.world;
                
                if (!world) {
                    resultsEl.innerHTML = '<div class="results-container"><p style="color: #ff4444;">Please generate a world first using the World Generation tab.</p></div>';
                    loadingEl.classList.remove('active');
                    return;
                }
                
                if (!world.dungeons || world.dungeons.length === 0) {
                    resultsEl.innerHTML = '<div class="results-container"><p style="color: #ffd700;">No dungeons found. Generate a world with Level 7.5 (Dungeons) enabled to create the dungeon registry.</p></div>';
                    loadingEl.classList.remove('active');
                    return;
                }
                
                displayDungeonRegistry(world);
                loadingEl.classList.remove('active');
            }, 100);
        }

        function displayDungeonRegistry(world) {
            const resultsEl = document.getElementById('dungeon-results');
            let html = '<div class="results-container">';
            html += `<h2 style="color: #ffd700; margin-bottom: 15px;">Dungeon Registry</h2>`;
            html += `<div style="color: #aaa; margin-bottom: 20px;">${world.dungeons.length} dungeons generated with world history and provenance</div>`;
            
            // Display each dungeon as a collapsible item
            world.dungeons.forEach((dungeon, index) => {
                const dungeonId = `dungeon-${index}`;
                html += `<div class="tree-node" style="margin-bottom: 15px;">`;
                html += `<span class="tree-toggle" data-level-id="${dungeonId}" style="cursor: pointer; user-select: none;">Γû╝</span>`;
                html += `<div style="display: inline-block; margin-left: 5px;">`;
                html += `<strong style="color: #ffd700; font-size: 1.1em;">${dungeon.name}</strong>`;
                html += ` <span style="color: #aaa;">(${dungeon.dungeonType})</span>`;
                html += `</div>`;
                
                // Collapsible content
                html += `<div class="tree-children expanded" id="${dungeonId}" style="margin-left: 25px; margin-top: 10px;">`;
                
                // Provenance information
                html += `<div class="entity-card" style="margin-bottom: 15px;">`;
                html += `<div class="entity-section-title" style="color: #ffd700; margin-bottom: 8px;">Provenance</div>`;
                
                // Creator info
                if (dungeon.createdBy === 'organization') {
                    const creator = world.organizations?.find(o => o.id === dungeon.creatorId);
                    if (creator) {
                        html += `<div style="color: #aaa; margin: 5px 0;">Created by Organization: <span style="color: #fff;">${creator.name}</span> (${creator.magnitude})</div>`;
                    }
                } else if (dungeon.createdBy === 'standout_mortal') {
                    const creator = world.standoutMortals?.find(m => m.id === dungeon.creatorId);
                    if (creator) {
                        html += `<div style="color: #aaa; margin: 5px 0;">Created by: <span style="color: #fff;">${creator.name}</span> (${creator.standoutType.replace(/_/g, ' ')})</div>`;
                    }
                }
                
                // Location
                const location = world.geography?.find(g => g.id === dungeon.location);
                if (location) {
                    html += `<div style="color: #aaa; margin: 5px 0;">Location: <span style="color: #fff;">${location.name}</span> (${location.geographyType.replace(/_/g, ' ')})</div>`;
                }
                
                html += `<div style="color: #aaa; margin: 5px 0;">Purpose: <span style="color: #fff;">${dungeon.purpose}</span></div>`;
                html += `<div style="color: #aaa; margin: 5px 0;">Age: <span style="color: #fff;">${Math.abs(dungeon.age)} years ago</span></div>`;
                html += `<div style="color: #aaa; margin: 5px 0;">Depth: <span style="color: #fff;">${dungeon.depth} levels</span></div>`;
                html += `</div>`;
                
                // Description
                html += `<div class="entity-card" style="margin-bottom: 15px;">`;
                html += `<div class="entity-section-title" style="color: #ffd700; margin-bottom: 8px;">Description</div>`;
                html += `<div style="color: #aaa; line-height: 1.6;">${dungeon.description}</div>`;
                html += `</div>`;
                
                // Boss information
                html += `<div class="entity-card" style="margin-bottom: 15px;">`;
                html += `<div class="entity-section-title" style="color: #ffd700; margin-bottom: 8px;">Bosses</div>`;
                
                // Final boss
                if (dungeon.finalBoss) {
                    const finalBoss = dungeon.finalBoss;
                    html += `<div style="color: #aaa; margin: 5px 0;">`;
                    html += `<strong style="color: #ff4444;">Final Boss (Level ${finalBoss.level}):</strong> `;
                    html += `<span style="color: #fff;">${finalBoss.bossName}</span>`;
                    html += ` <span style="color: #888;">(${finalBoss.bossType.replace(/_/g, ' ')})</span>`;
                    if (finalBoss.bossRace) {
                        html += ` - <span style="color: #aaa;">${finalBoss.bossRace}</span>`;
                    }
                    html += `</div>`;
                } else {
                    html += `<div style="color: #888; margin: 5px 0;">Final Boss: <span style="color: #aaa;">Not yet assigned</span></div>`;
                }
                
                // Mid-bosses
                if (dungeon.midBosses && dungeon.midBosses.length > 0) {
                    html += `<div style="color: #aaa; margin: 10px 0 5px 0;"><strong>Mid-Bosses:</strong></div>`;
                    html += `<ul style="color: #aaa; margin: 5px 0 5px 20px; font-size: 0.9em;">`;
                    dungeon.midBosses.forEach(midBoss => {
                        html += `<li>`;
                        html += `<strong style="color: #a335ee;">Level ${midBoss.level}:</strong> `;
                        html += `<span style="color: #fff;">${midBoss.bossName}</span>`;
                        html += ` <span style="color: #888;">(${midBoss.bossType.replace(/_/g, ' ')})</span>`;
                        if (midBoss.bossRace) {
                            html += ` - <span style="color: #aaa;">${midBoss.bossRace}</span>`;
                        }
                        html += `</li>`;
                    });
                    html += `</ul>`;
                } else {
                    html += `<div style="color: #888; margin: 5px 0;">Mid-Bosses: <span style="color: #aaa;">Not yet assigned</span></div>`;
                }
                
                html += `</div>`;
                
                // Room simulation section
                html += `<div class="entity-card">`;
                html += `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">`;
                html += `<div class="entity-section-title" style="color: #ffd700; margin: 0;">Room Generation</div>`;
                html += `<button onclick="window.simulateAllRooms(${index})" style="padding: 6px 12px; font-size: 0.85em; background: #16213e; border: 1px solid #0f3460; color: #ffd700; cursor: pointer; border-radius: 3px;">Simulate All Rooms</button>`;
                html += `</div>`;
                
                // Rooms display container (initially hidden)
                html += `<div id="rooms-display-${index}" style="display: none; margin-top: 15px;"></div>`;
                html += `<div style="margin-top: 10px; color: #888; font-size: 0.85em;">Note: Rooms are generated on-demand when players explore. Use "Simulate All Rooms" to preview room types and contents for all ${dungeon.depth} levels.</div>`;
                html += `<div style="margin-top: 5px; color: #888; font-size: 0.85em;">Seed: ${dungeon.seed}</div>`;
                html += `</div>`;
                
                html += `</div></div>`;
            });
            
            html += '</div>';
            resultsEl.innerHTML = html;
            
            // Attach toggle handlers
            resultsEl.querySelectorAll('.tree-toggle').forEach(toggle => {
                const dungeonId = toggle.getAttribute('data-level-id');
                if (dungeonId) {
                    toggle.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        if (window.toggleTreeLevel) {
                            window.toggleTreeLevel(dungeonId);
                        }
                        return false;
                    });
                }
            });
        }

        // ============================================================================
        // ROOM SIMULATION FOR DUNGEON REGISTRY
        // ============================================================================

        function simulateAllRooms(dungeonIndex) {
            const roomsContainer = document.getElementById(`rooms-display-${dungeonIndex}`);
            
            if (!roomsContainer) {
                console.error('Rooms container not found');
                return;
            }
            
            // Get full dungeon data from shared context
            const world = sharedContext.world;
            if (!world || !world.dungeons || !world.dungeons[dungeonIndex]) {
                roomsContainer.innerHTML = '<div style="color: #ff4444;">Error: Dungeon data not found. Please regenerate the world.</div>';
                return;
            }
            
            const dungeon = world.dungeons[dungeonIndex];
            
            // Show loading state
            roomsContainer.style.display = 'block';
            roomsContainer.innerHTML = '<div style="color: #aaa; font-style: italic;">Generating all rooms...</div>';
            
            setTimeout(() => {
                // Generate all rooms for this dungeon
                const rooms = generateAllRoomsForDungeon(dungeon, world);
                
                // Display all rooms in simplified format
                let html = `<div style="margin-top: 10px; border-top: 2px solid #16213e; padding-top: 10px;">`;
                html += `<div style="color: #ffd700; font-weight: bold; margin-bottom: 10px;">Generated Rooms (${rooms.length} total)</div>`;
                html += `<div style="max-height: 500px; overflow-y: auto;">`;
                
                rooms.forEach((room, roomIndex) => {
                    // Use different border color for boss rooms
                    const isBossRoom = room.type === 'boss';
                    const borderColor = isBossRoom ? '#ff4444' : '#ffd700';
                    const bgColor = isBossRoom ? '#2a1a1a' : '#1a1a2e';
                    
                    html += `<div style="padding: 6px 8px; margin-bottom: 5px; background: ${bgColor}; border-left: 3px solid ${borderColor}; border-radius: 3px; font-size: 0.9em;">`;
                    html += `<span style="color: #ffd700; font-weight: bold; margin-right: 10px;">Level ${room.level}:</span>`;
                    
                    // Room type
                    let typeDisplay = room.type.charAt(0).toUpperCase() + room.type.slice(1);
                    if (room.subtype) {
                        typeDisplay += ` (${room.subtype.replace(/_/g, ' ')})`;
                    }
                    html += `<span style="color: #fff; margin-right: 10px;">${typeDisplay}</span>`;
                    
                    // Sample contents based on room type
                    if (room.type === 'boss') {
                        // Boss room - show boss name
                        const bossName = room.bossInfo?.bossName || room.encounters?.[0] || 'Boss';
                        html += `<span style="color: #ff4444;">ΓåÆ <strong>Boss: ${bossName}</strong></span>`;
                    } else if (room.type === 'combat' && room.encounters && room.encounters.length > 0) {
                        html += `<span style="color: #aaa;">ΓåÆ ${room.encounters.join(', ')}</span>`;
                    } else if (room.type === 'safe') {
                        if (room.subtype === 'treasure') {
                            html += `<span style="color: #aaa;">ΓåÆ Safe room with treasure</span>`;
                        } else {
                            html += `<span style="color: #aaa;">ΓåÆ Safe room (rest/heal)</span>`;
                        }
                    } else if (room.type === 'trap') {
                        if (room.subtype === 'mechanical') {
                            html += `<span style="color: #aaa;">ΓåÆ Mechanical traps</span>`;
                        } else if (room.subtype === 'magical') {
                            html += `<span style="color: #aaa;">ΓåÆ Magical traps</span>`;
                        } else if (room.subtype === 'ambush') {
                            if (room.encounters && room.encounters.length > 0) {
                                html += `<span style="color: #aaa;">ΓåÆ Ambush (${room.encounters.join(', ')})</span>`;
                            } else {
                                html += `<span style="color: #aaa;">ΓåÆ Ambush room</span>`;
                            }
                        } else if (room.subtype === 'trapped_treasure') {
                            html += `<span style="color: #aaa;">ΓåÆ Trapped treasure</span>`;
                        } else if (room.subtype === 'puzzle') {
                            html += `<span style="color: #aaa;">ΓåÆ Puzzle room</span>`;
                        }
                    }
                    
                    html += `</div>`;
                });
                
                html += `</div>`;
                html += `</div>`;
                
                roomsContainer.innerHTML = html;
            }, 100);
        }
        
        function generateAllRoomsForDungeon(dungeon, world) {
            const rooms = [];
            const startZ = dungeon.dungeonType === 'dungeon' ? -1 : 1;
            const increment = dungeon.dungeonType === 'dungeon' ? -1 : 1;
            
            // Create a map of boss levels for quick lookup
            const bossLevels = new Map();
            if (dungeon.finalBoss) {
                bossLevels.set(dungeon.finalBoss.level, dungeon.finalBoss);
            }
            if (dungeon.midBosses) {
                dungeon.midBosses.forEach(midBoss => {
                    bossLevels.set(midBoss.level, midBoss);
                });
            }
            
            // Generate a room for each level
            for (let i = 0; i < dungeon.depth; i++) {
                const z = startZ + (i * increment);
                const levelNum = Math.abs(z);
                
                // Check if this level has a boss assigned
                const boss = bossLevels.get(levelNum);
                if (boss) {
                    // Generate boss room instead of regular room
                    const bossRoom = generateBossRoom(levelNum, boss, dungeon, world);
                    rooms.push(bossRoom);
                } else {
                    // Generate regular room
                    const levelSeed = `${dungeon.seed}-level-${levelNum}`;
                    const room = generateRoomForLevel(levelNum, levelSeed, dungeon, world);
                    rooms.push(room);
                }
            }
            
            return rooms;
        }
        
        function generateBossRoom(levelNum, boss, dungeon, world) {
            // Boss rooms are special - they contain the boss encounter
            const theme = determineDungeonTheme(dungeon.purpose);
            const isFinalBoss = levelNum === dungeon.depth;
            
            return {
                seed: `${dungeon.seed}-boss-${levelNum}`,
                name: isFinalBoss ? 'Boss Chamber' : 'Mid-Boss Arena',
                type: 'boss',
                subtype: isFinalBoss ? 'final' : 'mid',
                theme: theme,
                level: levelNum,
                description: isFinalBoss 
                    ? `The final chamber of the dungeon, where ${boss.bossName} awaits.`
                    : `An arena where ${boss.bossName} guards this level.`,
                encounters: [boss.bossName], // Boss encounter
                bossInfo: {
                    bossId: boss.bossId,
                    bossType: boss.bossType,
                    bossName: boss.bossName,
                    bossRace: boss.bossRace,
                    bossAlignment: boss.bossAlignment,
                },
                features: [],
            };
        }
        
        function generateRoomForLevel(levelNum, roomSeed, dungeon, world) {
            // Use the provided seed (deterministic for the same dungeon/level combination)
            const rng = new SeededRNG(roomSeed);
            
            // Determine theme based on dungeon purpose
            const theme = determineDungeonTheme(dungeon.purpose);
            
            // Room type distribution: 60% combat, 20% safe, 20% trap
            const roomTypeRoll = rng.random();
            let roomType;
            let roomSubtype = null;
            
            if (roomTypeRoll < 0.6) {
                roomType = 'combat';
            } else if (roomTypeRoll < 0.8) {
                roomType = 'safe';
                // Safe room subtypes: 50% regular safe room, 50% treasure room
                roomSubtype = rng.random() < 0.5 ? 'regular' : 'treasure';
            } else {
                roomType = 'trap';
                // Trap room subtypes - equal distribution (20% each)
                const trapSubtypeRoll = rng.random();
                if (trapSubtypeRoll < 0.2) {
                    roomSubtype = 'mechanical';
                } else if (trapSubtypeRoll < 0.4) {
                    roomSubtype = 'magical';
                } else if (trapSubtypeRoll < 0.6) {
                    roomSubtype = 'ambush';
                } else if (trapSubtypeRoll < 0.8) {
                    roomSubtype = 'trapped_treasure';
                } else {
                    roomSubtype = 'puzzle';
                }
            }
            
            // Get boss information to theme encounters
            const bossInfo = getDungeonBossInfo(dungeon, world);
            
            // Generate room name
            const roomName = generateRoomName(roomType, roomSubtype, theme, rng);
            
            // Generate description
            const description = generateRoomDescription(roomType, roomSubtype, theme, rng);
            
            // Generate encounters (for combat rooms and some trap rooms)
            const encounters = generateRoomEncounters(roomType, roomSubtype, levelNum, bossInfo, rng);
            
            // Generate features (optional, may be removed later)
            const features = generateRoomFeatures(theme, rng);
            
            return {
                seed: roomSeed,
                name: roomName,
                type: roomType,
                subtype: roomSubtype,
                theme: theme,
                level: levelNum,
                description: description,
                encounters: encounters,
                features: features,
            };
        }
        
        // Make simulateAllRooms globally accessible
        window.simulateAllRooms = simulateAllRooms;
        
        function determineDungeonTheme(dungeonPurpose) {
            if (!dungeonPurpose) return 'Generic Dungeon';
            
            const purposeLower = dungeonPurpose.toLowerCase();
            
            // Map dungeon purposes to themes
            if (purposeLower.includes('mining')) return 'Mineshaft';
            if (purposeLower.includes('fortress') || purposeLower.includes('citadel') || purposeLower.includes('stronghold')) return 'Fortress';
            if (purposeLower.includes('vault')) return 'Vault';
            if (purposeLower.includes('temple')) return 'Temple';
            if (purposeLower.includes('prison')) return 'Prison';
            if (purposeLower.includes('laboratory')) return 'Laboratory';
            if (purposeLower.includes('barracks')) return 'Barracks';
            if (purposeLower.includes('warehouse')) return 'Warehouse';
            if (purposeLower.includes('necromantic') || purposeLower.includes('research')) return 'Necromantic Lab';
            if (purposeLower.includes('tower') || purposeLower.includes('undeath')) return 'Tower';
            if (purposeLower.includes('phylactery') || purposeLower.includes('sanctum') || purposeLower.includes('citadel')) return 'Sanctum';
            if (purposeLower.includes('library') || purposeLower.includes('arcane')) return 'Arcane Library';
            if (purposeLower.includes('lair') || purposeLower.includes('base')) return 'Lair';
            if (purposeLower.includes('crypt') || purposeLower.includes('blood')) return 'Crypt';
            
            return 'Generic Dungeon';
        }
        
        function getDungeonBossInfo(dungeon, world) {
            // First check if dungeon has a final boss assigned (new system)
            if (dungeon.finalBoss) {
                const finalBoss = dungeon.finalBoss;
                
                if (finalBoss.bossType === 'demigod') {
                    const demigod = world.demiGods?.find(d => d.id === finalBoss.bossId);
                    if (demigod) {
                        return {
                            type: 'demigod',
                            name: demigod.name,
                            race: demigod.halfGodRace || undefined,
                            alignment: demigod.alignment || finalBoss.bossAlignment,
                        };
                    }
                } else if (finalBoss.bossType === 'standout_mortal') {
                    const mortal = world.standoutMortals?.find(m => m.id === finalBoss.bossId);
                    if (mortal) {
                        return {
                            type: 'standout_mortal',
                            standoutType: mortal.standoutType,
                            race: mortal.race || finalBoss.bossRace,
                            alignment: mortal.alignment || finalBoss.bossAlignment,
                            name: mortal.name,
                        };
                    }
                } else if (finalBoss.bossType === 'procgen') {
                    // Proc-gen boss - use the boss info directly
                    return {
                        type: 'procgen',
                        name: finalBoss.bossName,
                        race: finalBoss.bossRace,
                        alignment: finalBoss.bossAlignment,
                    };
                }
            }
            
            // Fallback: Try to determine boss from creator (old system)
            let boss = null;
            
            if (dungeon.createdBy === 'standout_mortal') {
                boss = world.standoutMortals?.find(m => m.id === dungeon.creatorId);
            } else if (dungeon.createdBy === 'organization') {
                // Organizations might have standout mortals as leaders
                const org = world.organizations?.find(o => o.id === dungeon.creatorId);
                if (org) {
                    // Return organization info for theming
                    return {
                        type: 'organization',
                        race: org.race || org.metadata?.organizationRace,
                        name: org.name,
                    };
                }
            }
            
            if (boss) {
                return {
                    type: 'standout_mortal',
                    standoutType: boss.standoutType,
                    race: boss.race,
                    alignment: boss.alignment,
                    name: boss.name,
                };
            }
            
            return null;
        }
        
        function generateRoomName(roomType, roomSubtype, theme, rng) {
            if (roomType === 'combat') {
                const names = ['Battle Chamber', 'Combat Hall', 'Fighting Grounds', 'Arena', 'War Room'];
                return rng.choice(names);
            } else if (roomType === 'safe') {
                if (roomSubtype === 'treasure') {
                    const names = ['Treasure Vault', 'Loot Room', 'Hoard Chamber', 'Wealth Vault'];
                    return rng.choice(names);
                } else {
                    const names = ['Safe Room', 'Rest Area', 'Sanctuary', 'Shelter'];
                    return rng.choice(names);
                }
            } else if (roomType === 'trap') {
                if (roomSubtype === 'mechanical') {
                    return 'Mechanical Trap Room';
                } else if (roomSubtype === 'magical') {
                    return 'Magical Trap Room';
                } else if (roomSubtype === 'ambush') {
                    return 'Ambush Room';
                } else if (roomSubtype === 'trapped_treasure') {
                    return 'Trapped Treasure Room';
                } else if (roomSubtype === 'puzzle') {
                    return 'Puzzle Room';
                }
            }
            
            return 'Room';
        }
        
        function generateRoomDescription(roomType, roomSubtype, theme, rng) {
            const themeText = theme.toLowerCase();
            
            if (roomType === 'combat') {
                return `A combat encounter room within the ${themeText}.`;
            } else if (roomType === 'safe') {
                if (roomSubtype === 'treasure') {
                    return `A safe room containing treasure within the ${themeText}. Players can rest, heal, and collect loot here.`;
                } else {
                    return `A safe room within the ${themeText}. Players can rest, heal, and regain spells here.`;
                }
            } else if (roomType === 'trap') {
                if (roomSubtype === 'mechanical') {
                    return `A room filled with mechanical traps within the ${themeText}. Requires perception check to find/identify traps, then dex check to disarm. Failure results in damage.`;
                } else if (roomSubtype === 'magical') {
                    return `A room filled with magical traps within the ${themeText}. Requires perception check to find/identify traps, then arcana check to disarm. Failure results in damage.`;
                } else if (roomSubtype === 'ambush') {
                    return `A room that appears to be a safe room within the ${themeText}. If perception check is failed, an encounter starts with enemies going first with advantage.`;
                } else if (roomSubtype === 'trapped_treasure') {
                    // Trapped treasure can be either mechanical or magical
                    const trapType = rng.random() < 0.5 ? 'mechanical' : 'magical';
                    const checkType = trapType === 'mechanical' ? 'dex' : 'arcana';
                    return `A room that appears to be a treasure room within the ${themeText}. Actually contains ${trapType} traps. Requires perception check to find/identify traps, then ${checkType} check to disarm. Failure results in damage. May result in treasure if checks pass.`;
                } else if (roomSubtype === 'puzzle') {
                    return `A puzzle room within the ${themeText}. Contains puzzles that block progression (mechanical or magical, no damage). Puzzles are eventually solvable, but failed checks cost time.`;
                }
            }
            
            return `A room within the ${themeText}.`;
        }
        
        function generateRoomEncounters(roomType, roomSubtype, levelNum, bossInfo, rng) {
            // Combat rooms always have encounters
            if (roomType === 'combat') {
                return generateThemedEncounters(levelNum, bossInfo, rng);
            }
            
            // Ambush rooms have encounters if perception check is failed
            if (roomType === 'trap' && roomSubtype === 'ambush') {
                return generateThemedEncounters(levelNum, bossInfo, rng);
            }
            
            // Other trap rooms don't have encounters (traps handle themselves)
            // Safe rooms don't have encounters
            return [];
        }
        
        function generateThemedEncounters(levelNum, bossInfo, rng) {
            const encounterCount = rng.random() < 0.5 ? 1 : 2;
            const encounters = [];
            
            // Get monster types based on boss theme
            let monsterTypes = getThemedMonsters(bossInfo);
            
            for (let i = 0; i < encounterCount; i++) {
                const monster = rng.choice(monsterTypes);
                const count = rng.range(1, 4);
                encounters.push(`${count}${count > 1 ? 'x' : ''} ${monster}${count > 1 ? 's' : ''}`);
            }
            
            return encounters;
        }
        
        function getThemedMonsters(bossInfo) {
            if (!bossInfo) {
                // Generic monsters if no boss info
                return ['Skeleton', 'Zombie', 'Goblin', 'Orc', 'Troll', 'Giant Spider'];
            }
            
            // Theme monsters based on boss
            if (bossInfo.type === 'standout_mortal') {
                const standoutType = bossInfo.standoutType || '';
                
                // Orc war-chief theme
                if (standoutType.includes('war') || standoutType.includes('chief') || bossInfo.race === 'Orc') {
                    return ['Orc', 'Orc Warrior', 'Orc Shaman', 'Orc Berserker', 'Goblin', 'Hobgoblin', 'Troll'];
                }
                
                // Undead theme (necromancer, lich, vampire)
                if (standoutType.includes('necro') || standoutType.includes('lich') || standoutType.includes('vampire')) {
                    return ['Skeleton', 'Zombie', 'Ghoul', 'Wraith', 'Shadow', 'Lich', 'Vampire Spawn'];
                }
                
                // Magic user theme
                if (standoutType.includes('wizard') || standoutType.includes('mage') || standoutType.includes('sorcerer')) {
                    return ['Arcane Construct', 'Magical Guardian', 'Spellcaster', 'Elemental', 'Golem'];
                }
            }
            
            // Organization-based theming (race-based)
            if (bossInfo.type === 'organization' && bossInfo.race) {
                const race = bossInfo.race.toLowerCase();
                
                if (race.includes('orc')) {
                    return ['Orc', 'Orc Warrior', 'Goblin', 'Troll'];
                } else if (race.includes('human')) {
                    return ['Bandit', 'Mercenary', 'Guard', 'Knight'];
                } else if (race.includes('elf')) {
                    return ['Elf Warrior', 'Elf Archer', 'Elf Mage'];
                } else if (race.includes('dwarf')) {
                    return ['Dwarf Warrior', 'Dwarf Defender'];
                }
            }
            
            // Default generic monsters
            return ['Skeleton', 'Zombie', 'Goblin', 'Orc', 'Troll', 'Giant Spider'];
        }
        
        function generateRoomFeatures(theme, rng) {
            // Optional flavor features - may be removed later
            const features = [];
            
            const commonFeatures = [
                'Ancient Carvings', 'Torch Sconces', 'Weathered Statues',
                'Collapsed Pillars', 'Old Furniture', 'Dusty Tapestries'
            ];
            
            if (rng.random() < 0.6) {
                features.push(rng.choice(commonFeatures));
            }
            
            return features;
        }

        // ============================================================================
        // OLD MAP GENERATION CODE (TO BE REMOVED)
        // ============================================================================

        function viewWorldContent() {
            const loadingEl = document.getElementById('map-loading');
            const resultsEl = document.getElementById('map-results');
            
            loadingEl.classList.add('active');
            resultsEl.innerHTML = '';
            
            setTimeout(() => {
                const world = sharedContext.world;
                
                if (!world) {
                    resultsEl.innerHTML = '<div class="results-container"><p style="color: #ff4444;">Please generate a world first using the World Generation tab.</p></div>';
                    loadingEl.classList.remove('active');
                    return;
                }
                
                displayWorldContent(world);
                
                loadingEl.classList.remove('active');
            }, 100);
        }

        function generateMapCells(seed, region, useWorldContext, includeDungeons) {
            const cells = [];
            const world = sharedContext.world;
            
            for (let x = region.xMin; x <= region.xMax; x++) {
                for (let y = region.yMin; y <= region.yMax; y++) {
                    const cellSeed = hashString(seed + '-cell-' + x + '-' + y);
                    const cellRng = new SeededRNG(cellSeed);
                    
                    // Check for geography at this location
                    let geography = null;
                    let locationId = null;
                    
                    if (useWorldContext && world && world.geography) {
                        // Try exact coordinate match first
                        geography = findGeographyAtCoordinates(x, y, world);
                        
                        // If no exact match, use deterministic mapping
                        if (!geography) {
                            locationId = mapCoordinatesToGeography(x, y, seed, world);
                            if (locationId) {
                                geography = world.geography.find(g => g.id === locationId);
                            }
                        } else {
                            locationId = geography.id;
                        }
                    }
                    
                    const features = [];
                    if (geography) {
                        features.push({ type: 'geography', id: geography.id, name: geography.name });
                    }
                    
                    // Check for organizations at this location
                    if (useWorldContext && world && world.organizations) {
                        const orgAtLocation = world.organizations.find(org => {
                            if (!org.location) return false;
                            const orgGeo = world.geography.find(g => g.id === org.location);
                            if (!orgGeo || !orgGeo.location) return false;
                            const dist = Math.sqrt(Math.pow(orgGeo.location.x - x, 2) + Math.pow(orgGeo.location.y - y, 2));
                            return dist < 3; // Within 3 units
                        });
                        if (orgAtLocation) {
                            features.push({ type: 'organization', id: orgAtLocation.id, name: orgAtLocation.name, org: orgAtLocation });
                        }
                    }
                    
                    // Random features
                    if (cellRng.random() < 0.1) {
                        const featureTypes = ['landmark', 'ruin', 'trading_post'];
                        features.push({ type: cellRng.choice(featureTypes), name: generateFeatureName(cellRng) });
                    }
                    
                    // Dungeon entrance
                    const dungeonEntrances = [];
                    if (includeDungeons && cellRng.random() < 0.05) {
                        // Check for necromancer tower event at this location
                        let dungeonType = 'dungeon';
                        let dungeonName = (() => {
                            const prefixes = ['Dark', 'Forgotten', 'Ancient', 'Cursed', 'Shadowed'];
                            const nouns = ['Caverns', 'Dungeon', 'Labyrinth', 'Vaults', 'Depths'];
                            return `${cellRng.choice(prefixes)} ${cellRng.choice(nouns)}`;
                        })();
                        
                        if (useWorldContext && world && world.worldEvents && locationId) {
                            const towerEvents = world.worldEvents.filter(e => 
                                e.locationId === locationId && 
                                (e.type === 'built_tower' || e.type === 'constructed_tower')
                            );
                            if (towerEvents.length > 0) {
                                dungeonType = 'tower';
                                dungeonName = `Necromancer's Tower`;
                                // Link to the necromancer who built it
                                const event = towerEvents[0];
                                if (event.entityId && world.standoutMortals) {
                                    const necromancer = world.standoutMortals.find(m => m.id === event.entityId);
                                    if (necromancer) {
                                        dungeonName = `${necromancer.name}'s Tower`;
                                    }
                                }
                            }
                        }
                        
                        dungeonEntrances.push({
                            dungeonId: `${dungeonType}-${x}-${y}-${Date.now()}`,
                            surfaceX: x,
                            surfaceY: y,
                            name: dungeonName,
                            locationId: locationId,
                            dungeonType: dungeonType,
                        });
                    }
                    
                    cells.push({
                        x,
                        y,
                        seed: cellSeed,
                        features,
                        dungeonEntrances,
                        geographyId: locationId,
                    });
                }
            }
            
            return {
                seed,
                region,
                cells,
                generatedAt: new Date(),
            };
        }

        function generateFeatureName(rng) {
            const prefixes = ['Ancient', 'Lost', 'Forgotten', 'Hidden', 'Mysterious'];
            const nouns = ['Ruins', 'Tower', 'Temple', 'Outpost', 'Monument', 'Shrine'];
            return `${rng.choice(prefixes)} ${rng.choice(nouns)}`;
        }

        function displayMap(map, gridSize) {
            const resultsEl = document.getElementById('map-results');
            let html = '<div class="results-container">';
            html += `<h2 style="color: #ffd700; margin-bottom: 15px;">Generated Map</h2>`;
            html += `<div style="color: #aaa; margin-bottom: 20px;">Region: (${map.region.xMin}, ${map.region.yMin}) to (${map.region.xMax}, ${map.region.yMax}) | Cells: ${map.cells.length}</div>`;
            
            // Create grid visualization
            html += '<div class="map-grid-container">';
            html += '<div class="map-grid" style="grid-template-columns: repeat(' + (map.region.xMax - map.region.xMin + 1) + ', 1fr);">';
            
            // Sort cells by y then x for display
            const sortedCells = [...map.cells].sort((a, b) => {
                if (a.y !== b.y) return a.y - b.y;
                return a.x - b.x;
            });
            
            sortedCells.forEach(cell => {
                let classes = 'map-cell';
                let title = `(${cell.x}, ${cell.y})`;
                
                if (cell.geographyId) {
                    classes += ' has-geography';
                    title += ' [Geography]';
                }
                if (cell.features.some(f => f.type === 'organization')) {
                    classes += ' has-organization';
                    title += ' [Organization]';
                }
                if (cell.features.some(f => f.type === 'landmark')) {
                    classes += ' has-landmark';
                    title += ' [Landmark]';
                }
                if (cell.features.some(f => f.type === 'ruin')) {
                    classes += ' has-ruin';
                    title += ' [Ruin]';
                }
                if (cell.dungeonEntrances.length > 0) {
                    classes += ' has-dungeon';
                    title += ' [Dungeon]';
                }
                
                html += `<div class="${classes}" title="${title}" onclick="showCellDetails(${cell.x}, ${cell.y})">`;
                
                // Add symbols for features (priority order)
                if (cell.dungeonEntrances.length > 0) html += 'D';
                else if (cell.features.some(f => f.type === 'organization')) html += 'O';
                else if (cell.geographyId) html += 'G';
                else if (cell.features.some(f => f.type === 'landmark')) html += 'L';
                else if (cell.features.some(f => f.type === 'ruin')) html += 'R';
                else html += '┬╖';
                
                html += '</div>';
            });
            
            html += '</div></div>';
            
            // Cell details section
            html += '<div id="cell-details" style="margin-top: 20px; display: none;"></div>';
            
            html += '</div>';
            resultsEl.innerHTML = html;
            
            // Store cells globally for details function
            window.mapCells = map.cells;
        }

        function showCellDetails(x, y) {
            if (!window.mapCells) return;
            const cell = window.mapCells.find(c => c.x === x && c.y === y);
            if (!cell) return;
            
            const detailsEl = document.getElementById('cell-details');
            if (!detailsEl) return;
            
            let html = '<div class="entity-card">';
            html += `<div class="entity-name">Cell (${x}, ${y})</div>`;
            
            if (cell.geographyId) {
                const world = sharedContext.world;
                if (world && world.geography) {
                    const geo = world.geography.find(g => g.id === cell.geographyId);
                    if (geo) {
                        html += `<div class="entity-section"><div class="entity-section-title">Geography</div>`;
                        html += `<div>${geo.name} (${geo.geographyType})</div></div>`;
                    }
                }
            }
            
            if (cell.features.length > 0) {
                html += '<div class="entity-section"><div class="entity-section-title">Features</div>';
                cell.features.forEach(f => {
                    if (f.type === 'organization' && f.org) {
                        html += `<div class="entity-card" style="margin: 5px 0; padding: 10px;">`;
                        html += `<div class="entity-name">${f.org.name}</div>`;
                        html += `<div class="entity-type">${f.org.magnitude}</div>`;
                        html += `<div class="entity-description">${f.org.description}</div>`;
                        html += `<div style="margin-top: 5px; color: #aaa;">Members: ${f.org.members}</div>`;
                        html += `</div>`;
                    } else {
                        html += `<div>${f.name || f.type}</div>`;
                    }
                });
                html += '</div>';
            }
            
            if (cell.dungeonEntrances.length > 0) {
                html += '<div class="entity-section"><div class="entity-section-title">Dungeon Entrances</div>';
                cell.dungeonEntrances.forEach(d => {
                    html += `<div class="entity-card" style="margin: 5px 0; padding: 10px;">`;
                    html += `<div class="entity-name">${d.name}</div>`;
                    html += `<div class="entity-type">${d.dungeonType || 'dungeon'}</div>`;
                    if (d.locationId) {
                        const world = sharedContext.world;
                        if (world && world.geography) {
                            const geo = world.geography.find(g => g.id === d.locationId);
                            if (geo) {
                                html += `<div style="color: #aaa; margin-top: 5px;">Located in: ${geo.name}</div>`;
                            }
                        }
                        // Check for world events at this location
                        if (world && world.worldEvents) {
                            const towerEvents = world.worldEvents.filter(e => 
                                e.locationId === d.locationId && 
                                (e.type === 'built_tower' || e.type === 'constructed_tower')
                            );
                            if (towerEvents.length > 0) {
                                html += `<div style="color: #ffd700; margin-top: 5px;">Γ£¿ Linked to world event: Necromancer Tower Construction</div>`;
                                const event = towerEvents[0];
                                if (event.entityId && world.standoutMortals) {
                                    const necromancer = world.standoutMortals.find(m => m.id === event.entityId);
                                    if (necromancer) {
                                        html += `<div style="color: #aaa; margin-top: 3px;">Built by: ${necromancer.name} (${necromancer.standoutType})</div>`;
                                    }
                                }
                            }
                        }
                    }
                    html += `<div style="color: #888; margin-top: 5px; font-size: 0.85em;">Location ID: ${d.locationId || 'None'}</div>`;
                    html += `</div>`;
                });
                html += '</div>';
            }
            
            html += '</div>';
            detailsEl.innerHTML = html;
            detailsEl.style.display = 'block';
        }

        // ============================================================================
        // INTEGRATION FUNCTIONS
        // ============================================================================

        /**
         * Build dungeon world context from generated world and location
         * This bridges world-generation-system and themed-dungeon-generation
         * Matches the TypeScript implementation in world-context-builder.ts
         */
        function buildDungeonWorldContext(world, locationId) {
            if (!world || !locationId) {
                return {
                    locationId: locationId || null,
                    standoutMortals: undefined,
                    demiGods: undefined,
                    worldEvents: undefined,
                };
            }
            
            // Filter standout mortals by location (with full data mapping)
            const standoutMortals = world.standoutMortals 
                ? world.standoutMortals
                    .filter(m => m.location === locationId)
                    .map(m => ({
                        id: m.id,
                        name: m.name,
                        standoutType: m.standoutType,
                        location: m.location,
                        race: m.race, // Full: Mortal race ID
                        organization: m.organization, // Full: Organization ID if part of one
                        powers: m.powers || [],
                        level: m.level,
                        age: m.age,
                        alignment: m.alignment,
                        isBoss: m.isBoss,
                        // Full world content data
                        parentId: m.parentId,
                        createdAt: m.createdAt,
                        description: m.description,
                        metadata: m.metadata || {},
                    }))
                : [];
            
            // Get evil demi-gods that can be dungeon bosses (divine beings aren't tied to locations)
            const demiGods = world.demiGods
                ? world.demiGods
                    .filter(d => d.isBoss === true) // Only evil demi-gods are boss candidates
                    .map(d => ({
                        id: d.id,
                        name: d.name,
                        demiGodType: d.demiGodType,
                        origin: d.origin,
                        powers: d.powers || [],
                        age: d.age,
                        alignment: d.alignment,
                        isBoss: d.isBoss,
                        // Full world content data
                        parentId: d.parentId,
                        createdAt: d.createdAt,
                        description: d.description,
                        metadata: d.metadata || {},
                        // Subtype information
                        halfGodRace: d.halfGodRace,
                        ancientCreatureType: d.ancientCreatureType,
                        divineExperimentFeatures: d.divineExperimentFeatures,
                        fallenDivineType: d.fallenDivineType,
                        primordialSpawnType: d.primordialSpawnType,
                    }))
                : [];
            
            // Filter world events by location
            const worldEvents = world.worldEvents
                ? world.worldEvents
                    .filter(e => e.locationId === locationId)
                    .map(e => ({
                        type: e.type,
                        entityId: e.entityId,
                        locationId: e.locationId,
                        description: e.description,
                        year: e.year,
                        metadata: e.metadata || {},
                    }))
                : [];
            
            return {
                locationId,
                standoutMortals: standoutMortals.length > 0 ? standoutMortals : undefined,
                demiGods: demiGods.length > 0 ? demiGods : undefined,
                worldEvents: worldEvents.length > 0 ? worldEvents : undefined,
            };
        }

        /**
         * Map coordinates to geography ID deterministically
         * Uses seed-based hashing to assign coordinates to geography entries
         * Matches the TypeScript implementation in map-generator.ts
         */
        function mapCoordinatesToGeography(x, y, seed, world) {
            if (!world || !world.geography || world.geography.length === 0) {
                return null;
            }
            
            // Use deterministic hash-based selection
            const hash = hashString(`${seed}-${x}-${y}-geo`);
            const index = hash % world.geography.length;
            return world.geography[index]?.id || null;
        }
        
        /**
         * Find geography at or near coordinates
         * Checks if coordinates match geography location or are nearby
         */
        function findGeographyAtCoordinates(x, y, world) {
            if (!world || !world.geography) return null;
            
            // First, try exact match
            const exactMatch = world.geography.find(g => 
                g.location && g.location.x === x && g.location.y === y
            );
            if (exactMatch) return exactMatch;
            
            // Then try nearby (within 5 units)
            let closest = null;
            let closestDist = Infinity;
            
            world.geography.forEach(g => {
                if (g.location) {
                    const dist = Math.sqrt(
                        Math.pow(g.location.x - x, 2) + Math.pow(g.location.y - y, 2)
                    );
                    if (dist < 5 && dist < closestDist) {
                        closestDist = dist;
                        closest = g;
                    }
                }
            });
            
            return closest;
        }

        // ============================================================================
        // DUNGEON GENERATION SYSTEM (Basic Implementation)
        // ============================================================================

        const DUNGEON_THEMES = {
            undead: { name: 'Undead Crypt', description: 'A dark crypt filled with the restless dead.', atmosphere: 'The air is cold and heavy with the stench of decay.' },
            fire: { name: 'Volcanic Depths', description: 'A scorching dungeon deep within volcanic rock.', atmosphere: 'Intense heat radiates from the walls.' },
            ice: { name: 'Frozen Caverns', description: 'An icy dungeon where frost has frozen everything.', atmosphere: 'Bitter cold permeates the air.' },
            nature: { name: 'Overgrown Ruins', description: 'A dungeon reclaimed by nature.', atmosphere: 'Vines and roots have broken through the stone.' },
            shadow: { name: 'Shadow Realm', description: 'A dungeon where darkness has corrupted reality.', atmosphere: 'Darkness clings to everything like a physical presence.' },
            mechanical: { name: 'Ancient Workshop', description: 'A dungeon filled with ancient machinery.', atmosphere: 'The sound of grinding gears fills the air.' },
            abyssal: { name: 'Abyssal Depths', description: 'A dungeon corrupted by demonic energy.', atmosphere: 'The air reeks of sulfur and brimstone.' },
            crystal: { name: 'Crystal Caverns', description: 'A dungeon filled with magical crystals.', atmosphere: 'Brilliant crystals pulse with magical energy.' },
        };

        function generateDungeon() {
            const loadingEl = document.getElementById('dungeon-loading');
            const resultsEl = document.getElementById('dungeon-results');
            
            loadingEl.classList.add('active');
            resultsEl.innerHTML = '';
            
            setTimeout(() => {
                const seed = document.getElementById('dungeon-seed').value || Math.random().toString(36);
                const depth = parseInt(document.getElementById('dungeon-depth').value) || 100;
                const themeSelection = document.getElementById('dungeon-theme').value;
                const useWorldMapContext = document.getElementById('use-world-map-context').checked;
                const selectedLocation = document.getElementById('dungeon-location').value;
                
                const dungeon = generateDungeonContent(seed, depth, themeSelection, useWorldMapContext, selectedLocation);
                displayDungeon(dungeon);
                
                // Store in shared context
                sharedContext.dungeon = dungeon;
                updateContextPanel();
                
                loadingEl.classList.remove('active');
            }, 100);
        }

        function generateDungeonContent(seed, depth, themeSelection, useWorldMapContext, selectedLocationId) {
            const rng = new SeededRNG(seed);
            
            // Build world context first if requested
            let locationId = null;
            let worldContext = null;
            if (useWorldMapContext && sharedContext.map && sharedContext.world) {
                // Use selected location or find first dungeon entrance
                if (selectedLocationId) {
                    locationId = selectedLocationId;
                    worldContext = buildDungeonWorldContext(sharedContext.world, locationId);
                } else {
                    // Find a dungeon entrance from the map
                    const dungeonCell = sharedContext.map.cells.find(c => c.dungeonEntrances.length > 0);
                    if (dungeonCell && dungeonCell.dungeonEntrances.length > 0) {
                        locationId = dungeonCell.dungeonEntrances[0].locationId;
                        worldContext = buildDungeonWorldContext(sharedContext.world, locationId);
                    }
                }
            }
            
            // Select theme
            let theme;
            if (themeSelection === 'auto') {
                const themes = Object.keys(DUNGEON_THEMES);
                theme = DUNGEON_THEMES[rng.choice(themes)];
            } else {
                theme = DUNGEON_THEMES[themeSelection] || DUNGEON_THEMES.undead;
            }
            
            // Generate final boss - check for standout mortals first
            let finalBoss;
            let usedStandoutMortal = false;
            
            if (worldContext && worldContext.standoutMortals && worldContext.standoutMortals.length > 0) {
                // Filter for evil standout mortals that can be bosses
                const evilMortals = worldContext.standoutMortals.filter(m => 
                    m.isBoss === true // Use alignment-based isBoss flag
                );
                
                if (evilMortals.length > 0 && rng.random() < 0.4) {
                    // 40% chance to use an evil standout mortal as the boss
                    const selectedMortal = rng.choice(evilMortals);
                    finalBoss = {
                        id: `boss-final-${selectedMortal.id}`,
                        name: selectedMortal.name,
                        type: selectedMortal.standoutType.replace(/_/g, ' '),
                        level: depth,
                        difficulty: Math.min(10, Math.max(8, Math.floor(selectedMortal.level / 3))),
                        description: `${selectedMortal.name} is a ${selectedMortal.standoutType.replace(/_/g, ' ')} from the world, now ruling this dungeon. ${selectedMortal.description}`,
                        standoutMortalId: selectedMortal.id,
                        originalLevel: selectedMortal.level,
                    };
                    usedStandoutMortal = true;
                    
                    // Adjust theme if boss is a necromancer/lich
                    if (themeSelection === 'auto') {
                        if (selectedMortal.standoutType === 'necromancer' || selectedMortal.standoutType === 'lich') {
                            theme = DUNGEON_THEMES.undead;
                        }
                    }
                }
            }
            
            // Check for evil demi-gods if no standout mortal was used
            if (!finalBoss && worldContext && worldContext.demiGods && worldContext.demiGods.length > 0) {
                // Filter for evil demi-gods that can be bosses
                const evilDemiGods = worldContext.demiGods.filter(d => 
                    d.isBoss === true // Use alignment-based isBoss flag
                );
                
                if (evilDemiGods.length > 0 && rng.random() < 0.3) {
                    // 30% chance to use an evil demi-god as the boss
                    const selectedDemiGod = rng.choice(evilDemiGods);
                    
                    // Determine theme influence based on demi-god type
                    let themeInfluence = ['divine', 'power'];
                    if (selectedDemiGod.demiGodType === 'fallen_divine') {
                        themeInfluence = ['corruption', 'shadow'];
                    } else if (selectedDemiGod.demiGodType === 'ancient_creature') {
                        themeInfluence = ['beast', 'nature'];
                    } else if (selectedDemiGod.demiGodType === 'primordial_spawn') {
                        themeInfluence = ['elemental', 'chaos'];
                    }
                    
                    finalBoss = {
                        id: `boss-final-${selectedDemiGod.id}`,
                        name: selectedDemiGod.name,
                        type: selectedDemiGod.demiGodType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                        level: depth,
                        difficulty: Math.min(10, Math.max(7, Math.floor(selectedDemiGod.age / 100))), // Demi-gods start strong
                        description: `${selectedDemiGod.name} is a powerful ${selectedDemiGod.demiGodType.replace(/_/g, ' ')} from the world, now ruling this dungeon. ${selectedDemiGod.description || ''}`,
                        demiGodId: selectedDemiGod.id,
                        themeInfluence: themeInfluence,
                    };
                    
                    // Adjust theme based on demi-god type if auto-selected
                    if (themeSelection === 'auto' && themeInfluence.includes('corruption')) {
                        theme = DUNGEON_THEMES.shadow;
                    } else if (themeSelection === 'auto' && themeInfluence.includes('elemental')) {
                        theme = DUNGEON_THEMES.elemental;
                    }
                }
            }
            
            // Fallback to generating a boss
            if (!finalBoss) {
                const bossTypes = ['Lich', 'Ancient Dragon', 'Demon Lord', 'Vampire Lord', 'Dark Archmage'];
                const bossType = rng.choice(bossTypes);
                const bossNames = {
                    'Lich': ['Malachar the Eternal', 'Vex the Undying', 'Zephyr the Deathless'],
                    'Ancient Dragon': ['Drakon the Ancient', 'Ignis the Flame-Breath', 'Frostfang the Eternal'],
                    'Demon Lord': ['Balrog the Destroyer', 'Mephisto the Corruptor'],
                };
                const bossName = bossNames[bossType] ? rng.choice(bossNames[bossType]) : `${bossType} of the Depths`;
                
                finalBoss = {
                    id: `boss-final-${seed}`,
                    name: bossName,
                    type: bossType,
                    level: depth,
                    difficulty: 10,
                    description: `${bossName} is a powerful ${bossType.toLowerCase()} that rules the deepest level.`,
                };
                
                // Adjust theme if boss is a necromancer/lich
                if (themeSelection === 'auto') {
                    if (bossType.includes('Lich') || bossType.includes('Necromancer')) {
                        theme = DUNGEON_THEMES.undead;
                    }
                }
            }
            
            // Generate mid-bosses
            const midBossCount = Math.max(1, Math.floor(depth / 25));
            const midBosses = [];
            for (let i = 1; i <= midBossCount; i++) {
                const level = Math.floor((depth / (midBossCount + 1)) * i);
                const midBossTypes = ['Orc Warlord', 'Troll Chieftain', 'Dark Knight', 'Giant Spider Queen'];
                const midBossType = rng.choice(midBossTypes);
                midBosses.push({
                    id: `boss-mid-${seed}-${level}`,
                    name: `${midBossType} of Level ${level}`,
                    type: midBossType,
                    level: level,
                    difficulty: Math.min(8, Math.floor(level / 12.5)),
                });
            }
            
            // Generate provenance - check world events for tower construction
            let builder = 'Ancient Dwarven Kingdom';
            let age = 100;
            let builderMortalId = null;
            
            if (worldContext && worldContext.worldEvents) {
                const towerEvents = worldContext.worldEvents.filter(e => 
                    e.type === 'built_tower' || e.type === 'constructed_tower'
                );
                if (towerEvents.length > 0) {
                    // This is a necromancer tower
                    const event = towerEvents[0];
                    builder = 'Necromancer';
                    builderMortalId = event.entityId;
                    age = 50; // Towers are more recent
                } else {
                    // Use standard builder selection
                    const builders = ['Ancient Dwarven Kingdom', 'Forgotten Human Kingdom', 'Dark Necromancer Cult', 'Ancient Dragon Lair'];
                    builder = rng.choice(builders);
                    const ages = [50, 100, 200, 500, 1000];
                    age = rng.choice(ages);
                }
            } else {
                // Standard builder selection
                const builders = ['Ancient Dwarven Kingdom', 'Forgotten Human Kingdom', 'Dark Necromancer Cult', 'Ancient Dragon Lair'];
                builder = rng.choice(builders);
                const ages = [50, 100, 200, 500, 1000];
                age = rng.choice(ages);
            }
            
            // Create level layout structure
            const levels = [];
            for (let level = 1; level <= depth; level++) {
                let boss = null;
                if (level === depth) {
                    boss = finalBoss;
                } else {
                    const midBoss = midBosses.find(mb => mb.level === level);
                    if (midBoss) boss = midBoss;
                }
                
                levels.push({
                    level,
                    boss,
                    roomCount: rng.range(5, 15),
                    generated: false, // Rooms generated on-demand
                });
            }
            
            return {
                id: `dungeon-${seed}`,
                seed,
                name: `${theme.name} of ${finalBoss.name}`,
                theme: Object.keys(DUNGEON_THEMES).find(key => DUNGEON_THEMES[key].name === theme.name) || themeSelection,
                themeName: theme.name,
                depth,
                finalBoss,
                midBosses,
                levels,
                provenance: {
                    builder,
                    builderMortalId,
                    age,
                    history: builderMortalId 
                        ? `This tower was built ${age} years ago by a powerful necromancer from the world. Constructed through magical means, it radiates corruption and dread.`
                        : `This dungeon was built ${age} years ago by the ${builder}. Over time, it has been expanded to ${depth} levels deep.`,
                },
                locationId,
                worldContext,
                usedStandoutMortal,
                generatedAt: new Date(),
            };
        }

        function displayDungeon(dungeon) {
            const resultsEl = document.getElementById('dungeon-results');
            let html = '<div class="results-container">';
            html += `<h2 style="color: #ffd700; margin-bottom: 15px;">${dungeon.name}</h2>`;
            html += `<div style="color: #aaa; margin-bottom: 20px;">Theme: ${dungeon.themeName} | Depth: ${dungeon.depth} levels</div>`;
            
            // Theme description
            html += '<div class="entity-section"><div class="entity-section-title">Theme</div>';
            html += `<div>${DUNGEON_THEMES[dungeon.theme].description}</div>`;
            html += `<div style="font-style: italic; color: #888; margin-top: 5px;">${DUNGEON_THEMES[dungeon.theme].atmosphere}</div>`;
            html += '</div>';
            
            // Provenance
            html += '<div class="entity-section"><div class="entity-section-title">History</div>';
            html += `<div>${dungeon.provenance.history}</div>`;
            html += '</div>';
            
            // Integration info
            if (dungeon.locationId || dungeon.worldContext) {
                html += '<div class="entity-section"><div class="entity-section-title">World Integration</div>';
                if (dungeon.locationId) {
                    html += `<div style="color: #aaa;">Location: ${dungeon.locationId}</div>`;
                }
                if (dungeon.usedStandoutMortal) {
                    html += `<div style="color: #ffd700; margin-top: 5px;">Γ£¿ Boss is a standout mortal from the generated world!</div>`;
                }
                if (dungeon.worldContext && dungeon.worldContext.worldEvents && dungeon.worldContext.worldEvents.length > 0) {
                    html += `<div style="color: #aaa; margin-top: 5px;">World Events at location: ${dungeon.worldContext.worldEvents.length}</div>`;
                }
                html += '</div>';
            }
            
            // Final Boss
            html += '<div class="entity-section"><div class="entity-section-title">Final Boss (Level ' + dungeon.depth + ')</div>';
            html += `<div class="entity-card">`;
            html += `<div class="entity-name">${dungeon.finalBoss.name}</div>`;
            html += `<div class="entity-type">${dungeon.finalBoss.type}</div>`;
            html += `<div class="entity-description">${dungeon.finalBoss.description}</div>`;
            html += `<div style="margin-top: 5px;"><strong>Difficulty:</strong> ${dungeon.finalBoss.difficulty}/10</div>`;
            if (dungeon.finalBoss.standoutMortalId) {
                html += `<div style="margin-top: 5px; color: #ffd700;">Linked to world standout mortal: ${dungeon.finalBoss.standoutMortalId}</div>`;
            }
            html += `</div></div>`;
            
            // Mid-Bosses
            if (dungeon.midBosses.length > 0) {
                html += '<div class="entity-section"><div class="entity-section-title">Mid-Bosses</div>';
                dungeon.midBosses.forEach(boss => {
                    html += `<div class="entity-card">`;
                    html += `<div class="entity-name">${boss.name}</div>`;
                    html += `<div class="entity-type">Level ${boss.level} - ${boss.type}</div>`;
                    html += `<div><strong>Difficulty:</strong> ${boss.difficulty}/10</div>`;
                    html += `</div>`;
                });
                html += '</div>';
            }
            
            // Levels summary
            html += '<div class="entity-section"><div class="entity-section-title">Level Structure</div>';
            html += `<div style="color: #aaa;">${dungeon.depth} levels total. Rooms are generated on-demand.</div>`;
            html += `<div style="margin-top: 10px;">Use the "Generate Room" control to generate rooms for specific levels.</div>`;
            html += '</div>';
            
            html += '</div>';
            resultsEl.innerHTML = html;
        }

        function generateItems() {
            const loadingEl = document.getElementById('item-loading');
            const resultsEl = document.getElementById('item-results');
            
            loadingEl.classList.add('active');
            resultsEl.innerHTML = '';
            
            setTimeout(() => {
                const itemCount = parseInt(document.getElementById('item-count').value) || 10;
                const context = document.getElementById('item-context').value;
                const level = parseInt(document.getElementById('item-level').value) || 5;
                const classPreference = document.getElementById('item-class').value;
                const rarityModifier = parseInt(document.getElementById('rarity-modifier').value) || 100;
                const seed = document.getElementById('item-seed').value || null;

                const items = [];
                for (let i = 0; i < itemCount; i++) {
                    const itemSeed = seed ? hashString(seed + '-' + i) : null;
                    const itemGen = new ItemGenerator(itemSeed);
                    items.push(itemGen.generateItem(context, level, classPreference, rarityModifier, itemSeed));
                }

                displayItems(items);
                loadingEl.classList.remove('active');
            }, 100);
        }

        function displayItems(items) {
            const resultsEl = document.getElementById('item-results');
            
            // Count rarities
            const rarityCounts = {};
            items.forEach(item => {
                rarityCounts[item.rarity] = (rarityCounts[item.rarity] || 0) + 1;
            });

            let html = `
                <div class="results-container">
                    <h2 style="color: #ffd700; margin-bottom: 15px;">Generated Items (${items.length})</h2>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; margin-bottom: 20px;">
            `;
            
            Object.entries(rarityCounts).forEach(([rarity, count]) => {
                html += `
                    <div style="text-align: center; background: #0f3460; padding: 10px; border-radius: 4px;">
                        <div style="color: #aaa; font-size: 0.85em;">${rarity.charAt(0).toUpperCase() + rarity.slice(1)}</div>
                        <div style="color: #ffd700; font-size: 1.2em; font-weight: bold;">${count}</div>
                    </div>
                `;
            });
            
            html += '</div><div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 15px;">';
            
            items.forEach(item => {
                let statsHtml = '';
                if (item.damage) statsHtml += `<div style="display: flex; justify-content: space-between;"><span>Damage:</span><span>${item.damage}</span></div>`;
                if (item.attackBonus) statsHtml += `<div style="display: flex; justify-content: space-between;"><span>Attack:</span><span>${item.attackBonus}</span></div>`;
                if (item.ac) statsHtml += `<div style="display: flex; justify-content: space-between;"><span>AC:</span><span>${item.ac}</span></div>`;

                let propsHtml = '';
                if (item.requiredClass) propsHtml += `<div><strong>Class:</strong> ${item.requiredClass.charAt(0).toUpperCase() + item.requiredClass.slice(1)}</div>`;
                if (item.properties) propsHtml += `<div><strong>Properties:</strong> ${item.properties}</div>`;
                if (item.enhancements && item.enhancements.length > 0) {
                    propsHtml += `<div><strong>Enhancements:</strong> ${item.enhancements.join(', ')}</div>`;
                }

                const rarityClass = `rarity-${item.rarity}`;
                html += `
                    <div class="item-card" style="border-left: 4px solid var(--${item.rarity}-color, #9d9d9d);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <div class="item-name ${rarityClass}" style="font-size: 1.2em;">${item.name}</div>
                            <span style="padding: 2px 8px; background: #0f3460; border-radius: 3px; font-size: 0.8em; text-transform: uppercase; color: #ffd700;">${item.rarity}</span>
                        </div>
                        <div style="color: #aaa; font-size: 0.9em; margin-bottom: 8px;">${item.type}</div>
                        ${statsHtml ? `<div style="font-size: 0.9em; color: #ccc; margin: 8px 0;">${statsHtml}</div>` : ''}
                        ${propsHtml ? `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #16213e; font-size: 0.85em;">${propsHtml}</div>` : ''}
                        ${item.description ? `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #16213e; font-style: italic; color: #888; font-size: 0.9em;">${item.description}</div>` : ''}
                    </div>
                `;
            });
            
            html += '</div></div>';
            resultsEl.innerHTML = html;
        }

        function updateContextPanel() {
            if (sharedContext.world) {
                document.getElementById('context-world').style.display = 'block';
                document.getElementById('context-world-seed').textContent = sharedContext.world.seed || '-';
                const count = (sharedContext.world.primordials?.length || 0) +
                             (sharedContext.world.cosmicCreators?.length || 0) +
                             (sharedContext.world.geography?.length || 0) +
                             (sharedContext.world.mortalRaces?.length || 0) +
                             (sharedContext.world.organizations?.length || 0) +
                             (sharedContext.world.standoutMortals?.length || 0) +
                             (sharedContext.world.dungeons?.length || 0);
                document.getElementById('context-world-count').textContent = count;
                
                // Show integration stats
                const geoCount = sharedContext.world.geography?.length || 0;
                const orgCount = sharedContext.world.organizations?.length || 0;
                const standoutCount = sharedContext.world.standoutMortals?.length || 0;
                const eventCount = sharedContext.world.worldEvents?.length || 0;
                const dungeonCount = sharedContext.world.dungeons?.length || 0;
                
                let stats = `Geography: ${geoCount} | Organizations: ${orgCount}`;
                if (standoutCount > 0) stats += ` | Standouts: ${standoutCount}`;
                if (dungeonCount > 0) stats += ` | Dungeons: ${dungeonCount}`;
                if (eventCount > 0) stats += ` | Events: ${eventCount}`;
                
                const worldEl = document.getElementById('context-world');
                let statsEl = worldEl.querySelector('.context-stats');
                if (!statsEl) {
                    statsEl = document.createElement('div');
                    statsEl.className = 'context-stats';
                    statsEl.style.fontSize = '0.85em';
                    statsEl.style.color = '#aaa';
                    statsEl.style.marginTop = '5px';
                    worldEl.appendChild(statsEl);
                }
                statsEl.textContent = stats;
            } else {
                document.getElementById('context-world').style.display = 'none';
            }
            
            // Dungeon Registry
            if (sharedContext.world && sharedContext.world.dungeons && sharedContext.world.dungeons.length > 0) {
                document.getElementById('context-dungeon').style.display = 'block';
                document.getElementById('context-dungeon-count').textContent = sharedContext.world.dungeons.length;
            } else {
                document.getElementById('context-dungeon').style.display = 'none';
            }

            // Generated Party
            if (sharedContext.party && sharedContext.party.members) {
                document.getElementById('context-party').style.display = 'block';
                document.getElementById('context-party-count').textContent = sharedContext.party.members.length;
            } else {
                document.getElementById('context-party').style.display = 'none';
            }
        }

        function exportWorldContext() {
            if (!sharedContext.world) {
                alert('No world generated yet. Please generate a world first.');
                return;
            }
            const json = JSON.stringify(sharedContext.world, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'world-context.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function toggleWorldContext() {
            const useWorld = document.getElementById('use-world-context').checked;
            // Update UI based on world context availability
            if (useWorld && !sharedContext.world) {
                alert('No world context available. Please generate a world first.');
                document.getElementById('use-world-context').checked = false;
            }
        }

        function toggleWorldMapContext() {
            const useContext = document.getElementById('use-world-map-context').checked;
            const locationGroup = document.getElementById('location-selector-group');
            const locationSelect = document.getElementById('dungeon-location');
            
            if (useContext && sharedContext.map && sharedContext.map.cells) {
                locationGroup.style.display = 'block';
                
                // Populate location selector from map dungeon entrances
                locationSelect.innerHTML = '<option value="">Select location...</option>';
                const dungeonCells = sharedContext.map.cells.filter(c => c.dungeonEntrances.length > 0);
                
                if (dungeonCells.length > 0) {
                    dungeonCells.forEach(cell => {
                        cell.dungeonEntrances.forEach(entrance => {
                            const geoName = sharedContext.world && sharedContext.world.geography
                                ? sharedContext.world.geography.find(g => g.id === entrance.locationId)?.name || 'Unknown'
                                : 'Unknown';
                            const option = document.createElement('option');
                            option.value = entrance.locationId || '';
                            option.textContent = `(${cell.x}, ${cell.y}) - ${entrance.name} - ${geoName}`;
                            option.dataset.x = cell.x;
                            option.dataset.y = cell.y;
                            locationSelect.appendChild(option);
                        });
                    });
                } else {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = 'No dungeon entrances found on map';
                    locationSelect.appendChild(option);
                }
            } else {
                locationGroup.style.display = 'none';
                if (!sharedContext.map) {
                    alert('No map generated yet. Please generate a map first to use world+map context.');
                    document.getElementById('use-world-map-context').checked = false;
                } else if (!sharedContext.world) {
                    alert('No world generated yet. Please generate a world first.');
                    document.getElementById('use-world-map-context').checked = false;
                }
            }
        }

        function generateRoom() {
            if (!sharedContext.dungeon) {
                alert('No dungeon generated yet. Please generate a dungeon first.');
                return;
            }
            
            const level = parseInt(document.getElementById('room-level').value) || 1;
            const dungeon = sharedContext.dungeon;
            
            if (level < 1 || level > dungeon.depth) {
                alert(`Level must be between 1 and ${dungeon.depth}`);
                return;
            }
            
            const levelData = dungeon.levels.find(l => l.level === level);
            if (!levelData) {
                alert('Level not found');
                return;
            }
            
            // Generate room for this level
            const seed = dungeon.seed + '-room-' + level;
            const rng = new SeededRNG(seed);
            
            const roomTypes = ['combat', 'safe', 'trap', 'treasure', 'corridor'];
            const roomType = rng.choice(roomTypes);
            
            const roomNames = {
                combat: ['Battle Chamber', 'Combat Hall', 'Encounter Room', 'Fighting Grounds'],
                safe: ['Safe Room', 'Rest Area', 'Sanctuary', 'Shelter'],
                trap: ['Trapped Chamber', 'Pitfall Room', 'Trap Hall', 'Deadly Corridor'],
                treasure: ['Treasure Vault', 'Loot Room', 'Hoard Chamber', 'Wealth Vault'],
                corridor: ['Main Corridor', 'Passageway', 'Tunnel', 'Hallway'],
            };
            
            const roomName = rng.choice(roomNames[roomType] || ['Room']);
            
            const room = {
                id: `room-${level}-${Date.now()}`,
                level,
                type: roomType,
                name: roomName,
                description: `A ${roomType} room on level ${level}.`,
                generated: true,
            };
            
            // Display room
            const resultsEl = document.getElementById('dungeon-results');
            const roomHtml = `
                <div class="entity-card" style="margin-top: 15px; border-left: 4px solid #ffd700;">
                    <div class="entity-name">${room.name}</div>
                    <div class="entity-type">Level ${level} - ${roomType}</div>
                    <div class="entity-description">${room.description}</div>
                </div>
            `;
            
            // Find or create level structure section
            let levelSection = resultsEl.querySelector('.level-structure-rooms');
            if (!levelSection) {
                const container = resultsEl.querySelector('.results-container');
                if (container) {
                    levelSection = document.createElement('div');
                    levelSection.className = 'level-structure-rooms';
                    levelSection.style.marginTop = '20px';
                    container.appendChild(levelSection);
                }
            }
            
            if (levelSection) {
                levelSection.innerHTML = `<div class="entity-section-title">Generated Rooms</div>${roomHtml}`;
            }
        }

        // ============================================================================
        // PARTY GENERATION SYSTEM
        // ============================================================================

        // Shared context for party
        if (!sharedContext.party) {
            sharedContext.party = null;
        }

        /**
         * Generate test adventurer
         */
        function createTestAdventurer(heroClass, level, seed) {
            const rng = new SeededRNG(seed || Math.random().toString());
            
            // Hit dice by class
            const hitDice = {
                warrior: 10,
                mage: 6,
                rogue: 8,
                cleric: 8
            };

            // Generate stats based on method
            const statMethod = document.getElementById('stat-generation').value;
            let stats;
            
            if (statMethod === 'random') {
                stats = {
                    strength: roll3d6(rng),
                    dexterity: roll3d6(rng),
                    constitution: roll3d6(rng),
                    intelligence: roll3d6(rng),
                    wisdom: roll3d6(rng),
                    charisma: roll3d6(rng)
                };
            } else if (statMethod === 'heroic') {
                stats = {
                    strength: roll4d6DropLowest(rng),
                    dexterity: roll4d6DropLowest(rng),
                    constitution: roll4d6DropLowest(rng),
                    intelligence: roll4d6DropLowest(rng),
                    wisdom: roll4d6DropLowest(rng),
                    charisma: roll4d6DropLowest(rng)
                };
            } else {
                // Balanced point buy (27 points)
                stats = {
                    strength: 15,
                    dexterity: 14,
                    constitution: 13,
                    intelligence: 12,
                    wisdom: 10,
                    charisma: 8
                };
                
                // Adjust for class priorities
                if (heroClass === 'warrior') {
                    stats.strength = 16;
                    stats.constitution = 14;
                } else if (heroClass === 'mage') {
                    stats.intelligence = 16;
                    stats.dexterity = 13;
                } else if (heroClass === 'rogue') {
                    stats.dexterity = 16;
                    stats.strength = 13;
                } else if (heroClass === 'cleric') {
                    stats.wisdom = 16;
                    stats.constitution = 14;
                }
            }

            // Calculate modifiers
            const getModifier = (stat) => Math.floor((stat - 10) / 2);
            
            // Calculate HP
            const conModifier = getModifier(stats.constitution);
            const hitDie = hitDice[heroClass] || 8;
            const hitDieAverage = Math.floor(hitDie / 2) + 1;
            let maxHealth;
            if (level === 1) {
                maxHealth = hitDie + conModifier;
            } else {
                maxHealth = hitDie + conModifier + (level - 1) * (hitDieAverage + conModifier);
            }
            maxHealth = Math.max(1, maxHealth);

            // Calculate AC (base 10 + DEX modifier)
            const armorClass = 10 + getModifier(stats.dexterity);

            // Calculate Mana for mages/clerics
            const wisdomModifier = getModifier(stats.wisdom);
            const intModifier = getModifier(stats.intelligence);
            let maxMana = 0;
            if (heroClass === 'mage') {
                maxMana = 3 + intModifier + (level - 1) * 2;
            } else if (heroClass === 'cleric') {
                maxMana = 5 + wisdomModifier + (level - 1) * 3;
            }
            maxMana = Math.max(0, maxMana);

            // Generate hero identifier
            const tokenId = `test-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            
            return {
                heroId: {
                    tokenId: tokenId,
                    contractAddress: '0x0000000000000000000000000000000000000000',
                    chainId: 143
                },
                walletAddress: '0x0000000000000000000000000000000000000000',
                name: `${heroClass.charAt(0).toUpperCase() + heroClass.slice(1)} ${tokenId.slice(-4)}`,
                class: heroClass,
                level: level,
                experience: 0,
                stats: {
                    health: maxHealth,
                    maxHealth: maxHealth,
                    mana: maxMana,
                    maxMana: maxMana,
                    strength: stats.strength,
                    dexterity: stats.dexterity,
                    wisdom: stats.wisdom,
                    intelligence: stats.intelligence,
                    constitution: stats.constitution,
                    charisma: stats.charisma,
                    perception: 10 + getModifier(stats.wisdom),
                    armorClass: armorClass,
                    attackBonus: getModifier(heroClass === 'rogue' ? stats.dexterity : stats.strength),
                    spellAttackBonus: heroClass === 'mage' ? getModifier(stats.intelligence) : getModifier(stats.wisdom)
                },
                createdAt: new Date(),
                updatedAt: new Date()
            };
        }

        function roll3d6(rng) {
            let total = 0;
            for (let i = 0; i < 3; i++) {
                total += rng.range(1, 6);
            }
            return total;
        }

        function roll4d6DropLowest(rng) {
            const rolls = [];
            for (let i = 0; i < 4; i++) {
                rolls.push(rng.range(1, 6));
            }
            rolls.sort((a, b) => a - b);
            return rolls[1] + rolls[2] + rolls[3];
        }

        /**
         * Generate party
         */
        function generateParty() {
            const loadingEl = document.getElementById('party-loading');
            const resultsEl = document.getElementById('party-results');
            loadingEl.style.display = 'block';
            resultsEl.innerHTML = '';

            try {
                const partySize = parseInt(document.getElementById('party-size').value) || 4;
                const defaultLevel = parseInt(document.getElementById('party-level').value) || 5;
                const seed = document.getElementById('party-seed').value || Math.random().toString();

                // Get selected classes
                const selectedClasses = [];
                if (document.getElementById('class-warrior').checked) selectedClasses.push('warrior');
                if (document.getElementById('class-mage').checked) selectedClasses.push('mage');
                if (document.getElementById('class-rogue').checked) selectedClasses.push('rogue');
                if (document.getElementById('class-cleric').checked) selectedClasses.push('cleric');

                if (selectedClasses.length === 0) {
                    alert('Please select at least one class.');
                    loadingEl.style.display = 'none';
                    return;
                }

                // Create party members
                const partyMembers = [];
                const rng = new SeededRNG(seed);

                for (let i = 0; i < partySize; i++) {
                    const heroClass = selectedClasses[i % selectedClasses.length];
                    const memberSeed = seed + '-member-' + i;
                    const adventurer = createTestAdventurer(heroClass, defaultLevel, memberSeed);
                    partyMembers.push(adventurer);
                }

                // Store in shared context
                sharedContext.party = {
                    members: partyMembers,
                    seed: seed,
                    generatedAt: new Date()
                };

                // Update context panel
                updateContextPanel();

                // Display results
                displayPartyResults(partyMembers);
                
                // Update combat simulation dropdown
                updateCombatPartySelect();

                loadingEl.style.display = 'none';
            } catch (error) {
                console.error('Error generating party:', error);
                loadingEl.style.display = 'none';
                resultsEl.innerHTML = `<div style="color: #f00;">Error: ${error.message}</div>`;
            }
        }

        function displayPartyResults(partyMembers) {
            const resultsEl = document.getElementById('party-results');
            let html = '<div class="results-container">';
            html += '<h2 style="color: #ffd700; margin-bottom: 15px;">Generated Party</h2>';
            html += `<div style="margin-bottom: 20px; color: #aaa;">Party Size: ${partyMembers.length}</div>`;
            html += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px;">';

            partyMembers.forEach((member, index) => {
                const classColor = {
                    warrior: '#c41e3a',
                    mage: '#69ccf0',
                    rogue: '#fff569',
                    cleric: '#ffffff'
                };

                html += `<div class="entity-card" style="border-left: 4px solid ${classColor[member.class] || '#ffd700'};">`;
                html += `<div class="entity-name">${member.name}</div>`;
                html += `<div class="entity-type">Level ${member.level} ${member.class.charAt(0).toUpperCase() + member.class.slice(1)}</div>`;
                
                html += '<div class="entity-section">';
                html += '<div class="entity-section-title">Stats</div>';
                html += `<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px; font-size: 0.9em;">`;
                html += `<div><strong>STR:</strong> ${member.stats.strength} (${Math.floor((member.stats.strength - 10) / 2) >= 0 ? '+' : ''}${Math.floor((member.stats.strength - 10) / 2)})</div>`;
                html += `<div><strong>DEX:</strong> ${member.stats.dexterity} (${Math.floor((member.stats.dexterity - 10) / 2) >= 0 ? '+' : ''}${Math.floor((member.stats.dexterity - 10) / 2)})</div>`;
                html += `<div><strong>CON:</strong> ${member.stats.constitution} (${Math.floor((member.stats.constitution - 10) / 2) >= 0 ? '+' : ''}${Math.floor((member.stats.constitution - 10) / 2)})</div>`;
                html += `<div><strong>INT:</strong> ${member.stats.intelligence} (${Math.floor((member.stats.intelligence - 10) / 2) >= 0 ? '+' : ''}${Math.floor((member.stats.intelligence - 10) / 2)})</div>`;
                html += `<div><strong>WIS:</strong> ${member.stats.wisdom} (${Math.floor((member.stats.wisdom - 10) / 2) >= 0 ? '+' : ''}${Math.floor((member.stats.wisdom - 10) / 2)})</div>`;
                html += `<div><strong>CHA:</strong> ${member.stats.charisma} (${Math.floor((member.stats.charisma - 10) / 2) >= 0 ? '+' : ''}${Math.floor((member.stats.charisma - 10) / 2)})</div>`;
                html += `</div>`;
                html += '</div>';

                html += '<div class="entity-section">';
                html += '<div class="entity-section-title">Combat Stats</div>';
                html += `<div style="font-size: 0.9em;">`;
                html += `<div><strong>HP:</strong> ${member.stats.health}/${member.stats.maxHealth}</div>`;
                html += `<div><strong>AC:</strong> ${member.stats.armorClass}</div>`;
                if (member.stats.maxMana > 0) {
                    html += `<div><strong>Mana:</strong> ${member.stats.mana}/${member.stats.maxMana}</div>`;
                }
                html += `<div><strong>Attack Bonus:</strong> ${member.stats.attackBonus >= 0 ? '+' : ''}${member.stats.attackBonus}</div>`;
                html += `</div>`;
                html += '</div>';

                html += '</div>';
            });

            html += '</div></div>';
            resultsEl.innerHTML = html;
        }

        // ============================================================================
        // COMBAT SIMULATION SYSTEM
        // ============================================================================

        /**
         * Update combat party select dropdown
         */
        function updateCombatPartySelect() {
            const select = document.getElementById('combat-party-select');
            select.innerHTML = '<option value="">-- Select a party --</option>';
            
            if (sharedContext.party && sharedContext.party.members) {
                const option = document.createElement('option');
                option.value = 'current';
                option.textContent = `Generated Party (${sharedContext.party.members.length} members)`;
                select.appendChild(option);
            }
        }

        /**
         * Update combat dungeon select dropdown
         */
        function updateCombatDungeonSelect() {
            const select = document.getElementById('combat-dungeon-select');
            select.innerHTML = '<option value="">-- Select a dungeon --</option>';
            
            if (sharedContext.world && sharedContext.world.dungeons) {
                sharedContext.world.dungeons.forEach((dungeon, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `${dungeon.name} (${dungeon.depth} levels)`;
                    option.dataset.dungeonId = dungeon.id || index;
                    select.appendChild(option);
                });
            }
        }

        /**
         * Clear combat simulation results
         */
        function clearCombatResults() {
            const resultsEl = document.getElementById('combat-results');
            const loadingEl = document.getElementById('combat-loading');
            resultsEl.innerHTML = '';
            loadingEl.style.display = 'none';
        }

        /**
         * Handle fast mode checkbox change - disable show details if fast mode is enabled
         */
        function handleFastModeChange() {
            const fastModeCheckbox = document.getElementById('sim-fast-mode');
            const showDetailsCheckbox = document.getElementById('sim-show-details');
            
            if (fastModeCheckbox.checked) {
                showDetailsCheckbox.checked = false;
            }
        }

        /**
         * Handle show details checkbox change - disable fast mode if show details is enabled
         */
        function handleShowDetailsChange() {
            const fastModeCheckbox = document.getElementById('sim-fast-mode');
            const showDetailsCheckbox = document.getElementById('sim-show-details');
            
            if (showDetailsCheckbox.checked) {
                fastModeCheckbox.checked = false;
            }
        }

        /**
         * Simulate dungeon run
         */
        function simulateDungeonRun() {
            const loadingEl = document.getElementById('combat-loading');
            const resultsEl = document.getElementById('combat-results');
            loadingEl.style.display = 'block';
            resultsEl.innerHTML = '';

            try {
                // Get selected party
                const partySelect = document.getElementById('combat-party-select').value;
                if (!partySelect || !sharedContext.party || !sharedContext.party.members) {
                    alert('Please generate a party first in the Party Generation tab.');
                    loadingEl.style.display = 'none';
                    return;
                }

                const partyMembers = sharedContext.party.members;

                // Get selected dungeon
                const dungeonIndex = parseInt(document.getElementById('combat-dungeon-select').value);
                if (isNaN(dungeonIndex) || !sharedContext.world || !sharedContext.world.dungeons || !sharedContext.world.dungeons[dungeonIndex]) {
                    alert('Please select a dungeon from the registry.');
                    loadingEl.style.display = 'none';
                    return;
                }

                const dungeon = sharedContext.world.dungeons[dungeonIndex];
                const clericHealRatio = parseInt(document.getElementById('cleric-heal-ratio').value) / 100;
                const mageMagicRatio = parseInt(document.getElementById('mage-magic-ratio').value) / 100;
                const fastMode = document.getElementById('sim-fast-mode').checked;
                let showDetails = document.getElementById('sim-show-details').checked;
                const stopOnDefeat = document.getElementById('sim-stop-on-defeat').checked;

                // Fast mode automatically disables detailed logs
                if (fastMode) {
                    showDetails = false;
                }

                // Start simulation
                try {
                    runDungeonSimulation(partyMembers, dungeon, {
                        clericHealRatio,
                        mageMagicRatio,
                        fastMode,
                        showDetails,
                        stopOnDefeat
                    });
                    loadingEl.style.display = 'none';
                } catch (error) {
                    console.error('Error in dungeon simulation:', error);
                    loadingEl.style.display = 'none';
                    resultsEl.innerHTML = `<div style="color: #f00;">Error: ${error.message}</div>`;
                }

            } catch (error) {
                console.error('Error starting simulation:', error);
                loadingEl.style.display = 'none';
                resultsEl.innerHTML = `<div style="color: #f00;">Error: ${error.message}</div>`;
            }
        }

        // ============================================================================
        // COMBAT SYSTEM - JavaScript Port
        // ============================================================================

        /**
         * Calculate XP reward from CR (D&D 5e XP table)
         */
        function calculateXPFromCR(cr) {
            const xpTable = {
                0: 0,
                0.125: 25,
                0.25: 50,
                0.5: 100,
                1: 200,
                2: 450,
                3: 700,
                4: 1100,
                5: 1800,
                6: 2300,
                7: 2900,
                8: 3900,
                9: 5000,
                10: 5900,
                11: 7200,
                12: 8400,
                13: 10000,
                14: 11500,
                15: 13000,
                16: 15000,
                17: 18000,
                18: 20000,
                19: 22000,
                20: 25000,
                21: 33000,
                22: 41000,
                23: 50000,
                24: 62000,
                25: 75000,
                26: 90000,
                27: 105000,
                28: 120000,
                29: 135000,
                30: 155000,
            };
            return xpTable[cr] || 0;
        }

        /**
         * Create a simplified stat block
         */
        function createMonsterStatBlock(name, cr, hp, ac, strength, dexterity, wisdom) {
            return {
                name: name,
                hp: hp,
                ac: ac,
                cr: cr,
                xp: calculateXPFromCR(cr),
                strength: strength,
                dexterity: dexterity,
                wisdom: wisdom,
            };
        }

        /**
         * Monster Registry - All monsters
         */
        const ALL_MONSTERS = [
            // UNDEAD
            { name: 'Skeleton', theme: 'undead', isBoss: false, statBlock: createMonsterStatBlock('Skeleton', 0.25, 13, 13, 10, 16, 8) },
            { name: 'Zombie', theme: 'undead', isBoss: false, statBlock: createMonsterStatBlock('Zombie', 0.25, 22, 8, 13, 6, 6) },
            { name: 'Wraith', theme: 'undead', isBoss: false, statBlock: createMonsterStatBlock('Wraith', 5, 67, 13, 6, 16, 14) },
            { name: 'Ghost', theme: 'undead', isBoss: false, statBlock: createMonsterStatBlock('Ghost', 4, 45, 11, 7, 13, 12) },
            { name: 'Lich', theme: 'undead', isBoss: true, statBlock: createMonsterStatBlock('Lich', 21, 315, 20, 11, 16, 14) },
            { name: 'Banshee', theme: 'undead', isBoss: false, statBlock: createMonsterStatBlock('Banshee', 4, 58, 12, 1, 14, 11) },
            { name: 'Death Knight', theme: 'undead', isBoss: true, statBlock: createMonsterStatBlock('Death Knight', 17, 180, 20, 20, 11, 16) },
            { name: 'Mummy', theme: 'undead', isBoss: false, statBlock: createMonsterStatBlock('Mummy', 3, 58, 11, 16, 8, 12) },
            // FIRE
            { name: 'Fire Elemental', theme: 'fire', isBoss: false, statBlock: createMonsterStatBlock('Fire Elemental', 5, 102, 13, 10, 17, 10) },
            { name: 'Lava Golem', theme: 'fire', isBoss: false, statBlock: createMonsterStatBlock('Lava Golem', 10, 157, 17, 20, 8, 11) },
            { name: 'Salamander', theme: 'fire', isBoss: false, statBlock: createMonsterStatBlock('Salamander', 5, 90, 15, 18, 15, 10) },
            { name: 'Fire Imp', theme: 'fire', isBoss: false, statBlock: createMonsterStatBlock('Fire Imp', 0.5, 7, 13, 6, 17, 12) },
            { name: 'Magma Beast', theme: 'fire', isBoss: false, statBlock: createMonsterStatBlock('Magma Beast', 6, 126, 15, 19, 12, 10) },
            { name: 'Phoenix', theme: 'fire', isBoss: true, statBlock: createMonsterStatBlock('Phoenix', 16, 175, 18, 22, 12, 19) },
            { name: 'Hellhound', theme: 'fire', isBoss: false, statBlock: createMonsterStatBlock('Hellhound', 3, 45, 15, 17, 12, 13) },
            // ICE
            { name: 'Ice Elemental', theme: 'ice', isBoss: false, statBlock: createMonsterStatBlock('Ice Elemental', 5, 114, 14, 14, 14, 10) },
            { name: 'Frost Giant', theme: 'ice', isBoss: false, statBlock: createMonsterStatBlock('Frost Giant', 8, 138, 15, 23, 9, 10) },
            { name: 'Ice Golem', theme: 'ice', isBoss: false, statBlock: createMonsterStatBlock('Ice Golem', 5, 133, 15, 18, 9, 8) },
            { name: 'Frozen Wraith', theme: 'ice', isBoss: false, statBlock: createMonsterStatBlock('Frozen Wraith', 5, 67, 13, 6, 16, 14) },
            { name: 'Yeti', theme: 'ice', isBoss: false, statBlock: createMonsterStatBlock('Yeti', 3, 51, 12, 18, 13, 12) },
            { name: 'Ice Wyrm', theme: 'ice', isBoss: true, statBlock: createMonsterStatBlock('Ice Wyrm', 20, 200, 20, 26, 10, 13) },
            { name: 'Frost Troll', theme: 'ice', isBoss: false, statBlock: createMonsterStatBlock('Frost Troll', 5, 84, 15, 18, 13, 9) },
            // NATURE
            { name: 'Ent', theme: 'nature', isBoss: false, statBlock: createMonsterStatBlock('Ent', 2, 136, 16, 23, 8, 16) },
            { name: 'Treant', theme: 'nature', isBoss: false, statBlock: createMonsterStatBlock('Treant', 9, 138, 16, 23, 8, 16) },
            { name: 'Giant Spider', theme: 'nature', isBoss: false, statBlock: createMonsterStatBlock('Giant Spider', 1, 26, 14, 14, 16, 11) },
            { name: 'Venomous Plant', theme: 'nature', isBoss: false, statBlock: createMonsterStatBlock('Venomous Plant', 2, 51, 13, 15, 8, 10) },
            { name: 'Beast', theme: 'nature', isBoss: false, statBlock: createMonsterStatBlock('Beast', 1, 19, 12, 13, 12, 10) },
            { name: 'Druid', theme: 'nature', isBoss: false, statBlock: createMonsterStatBlock('Druid', 2, 27, 11, 10, 12, 15) },
            { name: 'Wild Boar', theme: 'nature', isBoss: false, statBlock: createMonsterStatBlock('Wild Boar', 0.25, 11, 11, 13, 11, 9) },
            { name: 'Dire Wolf', theme: 'nature', isBoss: false, statBlock: createMonsterStatBlock('Dire Wolf', 1, 37, 14, 17, 15, 12) },
            // SHADOW
            { name: 'Shadow', theme: 'shadow', isBoss: false, statBlock: createMonsterStatBlock('Shadow', 0.5, 16, 12, 6, 14, 10) },
            { name: 'Dark Stalker', theme: 'shadow', isBoss: false, statBlock: createMonsterStatBlock('Dark Stalker', 2, 27, 14, 11, 16, 10) },
            { name: 'Void Creature', theme: 'shadow', isBoss: false, statBlock: createMonsterStatBlock('Void Creature', 4, 45, 14, 12, 15, 11) },
            { name: 'Shadow Demon', theme: 'shadow', isBoss: false, statBlock: createMonsterStatBlock('Shadow Demon', 4, 66, 13, 1, 19, 13) },
            { name: 'Dark Mage', theme: 'shadow', isBoss: false, statBlock: createMonsterStatBlock('Dark Mage', 3, 40, 12, 9, 14, 12) },
            { name: 'Nightmare', theme: 'shadow', isBoss: false, statBlock: createMonsterStatBlock('Nightmare', 3, 68, 13, 18, 15, 13) },
            { name: 'Phantom', theme: 'shadow', isBoss: false, statBlock: createMonsterStatBlock('Phantom', 1, 22, 11, 6, 13, 12) },
            // MECHANICAL
            { name: 'Golem', theme: 'mechanical', isBoss: false, statBlock: createMonsterStatBlock('Golem', 5, 93, 15, 19, 9, 8) },
            { name: 'Construct', theme: 'mechanical', isBoss: false, statBlock: createMonsterStatBlock('Construct', 1, 30, 13, 15, 10, 8) },
            { name: 'Mechanical Spider', theme: 'mechanical', isBoss: false, statBlock: createMonsterStatBlock('Mechanical Spider', 1, 26, 15, 14, 16, 10) },
            { name: 'Automaton', theme: 'mechanical', isBoss: false, statBlock: createMonsterStatBlock('Automaton', 2, 39, 15, 16, 12, 10) },
            { name: 'Clockwork Beast', theme: 'mechanical', isBoss: false, statBlock: createMonsterStatBlock('Clockwork Beast', 3, 60, 16, 18, 13, 10) },
            { name: 'War Machine', theme: 'mechanical', isBoss: true, statBlock: createMonsterStatBlock('War Machine', 10, 157, 18, 22, 9, 11) },
            { name: 'Steel Guardian', theme: 'mechanical', isBoss: false, statBlock: createMonsterStatBlock('Steel Guardian', 5, 93, 16, 19, 9, 8) },
            // ABYSSAL
            { name: 'Demon', theme: 'abyssal', isBoss: false, statBlock: createMonsterStatBlock('Demon', 4, 45, 15, 13, 16, 11) },
            { name: 'Imp', theme: 'abyssal', isBoss: false, statBlock: createMonsterStatBlock('Imp', 1, 10, 13, 6, 17, 12) },
            { name: 'Succubus', theme: 'abyssal', isBoss: false, statBlock: createMonsterStatBlock('Succubus', 4, 66, 15, 8, 17, 12) },
            { name: 'Balrog', theme: 'abyssal', isBoss: true, statBlock: createMonsterStatBlock('Balrog', 19, 262, 18, 22, 15, 16) },
            { name: 'Fiend', theme: 'abyssal', isBoss: false, statBlock: createMonsterStatBlock('Fiend', 5, 65, 15, 15, 14, 13) },
            { name: 'Chaos Spawn', theme: 'abyssal', isBoss: false, statBlock: createMonsterStatBlock('Chaos Spawn', 2, 33, 13, 13, 14, 8) },
            // CRYSTAL
            { name: 'Crystal Golem', theme: 'crystal', isBoss: false, statBlock: createMonsterStatBlock('Crystal Golem', 10, 157, 17, 20, 9, 11) },
            { name: 'Arcane Construct', theme: 'crystal', isBoss: false, statBlock: createMonsterStatBlock('Arcane Construct', 5, 60, 15, 15, 12, 10) },
            { name: 'Crystal Spider', theme: 'crystal', isBoss: false, statBlock: createMonsterStatBlock('Crystal Spider', 2, 39, 15, 14, 16, 10) },
            { name: 'Mana Elemental', theme: 'crystal', isBoss: false, statBlock: createMonsterStatBlock('Mana Elemental', 5, 102, 13, 10, 17, 10) },
            { name: 'Crystal Beast', theme: 'crystal', isBoss: false, statBlock: createMonsterStatBlock('Crystal Beast', 3, 60, 16, 18, 13, 10) },
            { name: 'Arcane Guardian', theme: 'crystal', isBoss: true, statBlock: createMonsterStatBlock('Arcane Guardian', 12, 178, 18, 22, 9, 11) },
            // BANDIT
            { name: 'Bandit', theme: 'bandit', isBoss: false, statBlock: createMonsterStatBlock('Bandit', 0.125, 11, 12, 11, 12, 10) },
            { name: 'Bandit Veteran', theme: 'bandit', isBoss: false, statBlock: createMonsterStatBlock('Bandit Veteran', 3, 58, 15, 16, 16, 10) },
            { name: 'Bandit Leader', theme: 'bandit', isBoss: true, statBlock: createMonsterStatBlock('Bandit Leader', 2, 65, 15, 15, 16, 11) },
            { name: 'Thug', theme: 'bandit', isBoss: false, statBlock: createMonsterStatBlock('Thug', 0.5, 32, 11, 15, 11, 10) },
            { name: 'Mercenary', theme: 'bandit', isBoss: false, statBlock: createMonsterStatBlock('Mercenary', 3, 58, 16, 16, 14, 10) },
            { name: 'Outlaw', theme: 'bandit', isBoss: false, statBlock: createMonsterStatBlock('Outlaw', 1, 27, 14, 13, 16, 10) },
            { name: 'Raider', theme: 'bandit', isBoss: false, statBlock: createMonsterStatBlock('Raider', 2, 39, 14, 15, 14, 10) },
            { name: 'Cutthroat', theme: 'bandit', isBoss: false, statBlock: createMonsterStatBlock('Cutthroat', 1, 22, 14, 11, 16, 10) },
            // GOBLIN
            { name: 'Goblin', theme: 'goblin', isBoss: false, statBlock: createMonsterStatBlock('Goblin', 0.25, 7, 15, 8, 14, 8) },
            { name: 'Goblin Warrior', theme: 'goblin', isBoss: false, statBlock: createMonsterStatBlock('Goblin Warrior', 0.5, 15, 15, 10, 14, 8) },
            { name: 'Goblin Shaman', theme: 'goblin', isBoss: false, statBlock: createMonsterStatBlock('Goblin Shaman', 1, 18, 13, 8, 14, 13) },
            { name: 'Hobgoblin', theme: 'goblin', isBoss: false, statBlock: createMonsterStatBlock('Hobgoblin', 0.5, 11, 18, 13, 12, 10) },
            { name: 'Bugbear', theme: 'goblin', isBoss: false, statBlock: createMonsterStatBlock('Bugbear', 1, 27, 16, 15, 14, 11) },
            { name: 'Cave Rat', theme: 'goblin', isBoss: false, statBlock: createMonsterStatBlock('Cave Rat', 0, 1, 10, 2, 11, 10) },
            { name: 'Giant Bat', theme: 'goblin', isBoss: false, statBlock: createMonsterStatBlock('Giant Bat', 0.25, 22, 13, 15, 16, 12) },
            { name: 'Dire Weasel', theme: 'goblin', isBoss: false, statBlock: createMonsterStatBlock('Dire Weasel', 0.125, 7, 14, 11, 16, 12) },
            // NECROMANCER TOWER
            { name: 'Animated Golem', theme: 'necromancer-tower', isBoss: false, statBlock: createMonsterStatBlock('Animated Golem', 5, 93, 15, 19, 9, 8) },
            { name: 'Mimic', theme: 'necromancer-tower', isBoss: false, statBlock: createMonsterStatBlock('Mimic', 2, 58, 12, 17, 12, 13) },
            { name: 'Black Dragon', theme: 'necromancer-tower', isBoss: true, statBlock: createMonsterStatBlock('Black Dragon', 7, 127, 19, 19, 14, 11) },
            { name: 'Cultist', theme: 'necromancer-tower', isBoss: false, statBlock: createMonsterStatBlock('Cultist', 0.125, 9, 12, 11, 12, 11) },
            { name: 'Dark Acolyte', theme: 'necromancer-tower', isBoss: false, statBlock: createMonsterStatBlock('Dark Acolyte', 2, 27, 13, 10, 14, 11) },
            { name: 'Wight', theme: 'necromancer-tower', isBoss: false, statBlock: createMonsterStatBlock('Wight', 3, 45, 14, 15, 14, 13) },
            // GENERIC (includes common monsters)
            { name: 'Orc', theme: 'generic', isBoss: false, statBlock: createMonsterStatBlock('Orc', 0.5, 15, 13, 16, 12, 11) },
            { name: 'Spider', theme: 'generic', isBoss: false, statBlock: createMonsterStatBlock('Spider', 0, 1, 12, 2, 14, 10) },
            { name: 'Dragon', theme: 'generic', isBoss: true, statBlock: createMonsterStatBlock('Dragon', 10, 200, 18, 23, 10, 13) },
            { name: 'Giant', theme: 'generic', isBoss: true, statBlock: createMonsterStatBlock('Giant', 9, 162, 15, 25, 9, 10) },
            { name: 'Troll', theme: 'generic', isBoss: false, statBlock: createMonsterStatBlock('Troll', 5, 84, 15, 18, 13, 9) },
            { name: 'Orc Warrior', theme: 'generic', isBoss: false, statBlock: createMonsterStatBlock('Orc Warrior', 2, 45, 14, 16, 12, 11) },
            { name: 'Orc Shaman', theme: 'generic', isBoss: false, statBlock: createMonsterStatBlock('Orc Shaman', 3, 52, 13, 14, 13, 14) },
            { name: 'Orc Berserker', theme: 'generic', isBoss: false, statBlock: createMonsterStatBlock('Orc Berserker', 4, 68, 15, 18, 12, 11) },
            { name: 'Ghoul', theme: 'generic', isBoss: false, statBlock: createMonsterStatBlock('Ghoul', 1, 22, 12, 13, 15, 10) },
            { name: 'Vampire Spawn', theme: 'generic', isBoss: false, statBlock: createMonsterStatBlock('Vampire Spawn', 5, 82, 16, 16, 16, 12) },
            { name: 'Elf Warrior', theme: 'generic', isBoss: false, statBlock: createMonsterStatBlock('Elf Warrior', 2, 38, 16, 13, 16, 11) },
            { name: 'Elf Archer', theme: 'generic', isBoss: false, statBlock: createMonsterStatBlock('Elf Archer', 3, 45, 16, 13, 18, 11) },
            { name: 'Elf Mage', theme: 'generic', isBoss: false, statBlock: createMonsterStatBlock('Elf Mage', 4, 52, 13, 10, 16, 16) },
            { name: 'Dwarf Warrior', theme: 'generic', isBoss: false, statBlock: createMonsterStatBlock('Dwarf Warrior', 2, 42, 16, 15, 10, 11) },
            { name: 'Dwarf Defender', theme: 'generic', isBoss: false, statBlock: createMonsterStatBlock('Dwarf Defender', 3, 58, 18, 16, 10, 11) },
            { name: 'Guard', theme: 'generic', isBoss: false, statBlock: createMonsterStatBlock('Guard', 0.5, 22, 16, 13, 12, 10) },
            { name: 'Knight', theme: 'generic', isBoss: false, statBlock: createMonsterStatBlock('Knight', 3, 52, 18, 16, 11, 13) },
            { name: 'Spellcaster', theme: 'generic', isBoss: false, statBlock: createMonsterStatBlock('Spellcaster', 4, 45, 12, 9, 14, 16) },
            { name: 'Elemental', theme: 'generic', isBoss: false, statBlock: createMonsterStatBlock('Elemental', 5, 102, 13, 10, 17, 10) },
            { name: 'Magical Guardian', theme: 'generic', isBoss: false, statBlock: createMonsterStatBlock('Magical Guardian', 6, 114, 15, 18, 13, 12) },
        ];

        /**
         * Get monster by name
         */
        function getMonsterByName(name) {
            return ALL_MONSTERS.find(m => m.name.toLowerCase() === name.toLowerCase());
        }

        /**
         * Create monster instance for combat
         */
        function createMonsterInstance(statBlock, id) {
            return {
                id: id || `monster-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                statBlock: statBlock,
                currentHp: statBlock.hp,
                maxHp: statBlock.hp,
            };
        }

        /**
         * Create monster instance from name
         */
        function createMonsterInstanceByName(name, id) {
            const monster = getMonsterByName(name);
            if (!monster) return null;
            return createMonsterInstance(monster.statBlock, id);
        }

        /**
         * Default weapons for each class
         */
        const DEFAULT_WEAPONS = {
            warrior: {
                name: 'Sword',
                type: 'melee-strength',
                damageDice: '1d8',
                damageModifier: 0,
                attackModifier: 0,
            },
            rogue: {
                name: 'Dagger',
                type: 'melee-dexterity',
                damageDice: '1d4',
                damageModifier: 0,
                attackModifier: 0,
            },
            cleric: {
                name: 'Mace',
                type: 'melee-strength',
                damageDice: '1d6',
                damageModifier: 0,
                attackModifier: 0,
            },
            mage: {
                name: 'Staff',
                type: 'melee-strength',
                damageDice: '1d4',
                damageModifier: 0,
                attackModifier: 0,
            },
        };

        /**
         * Cleric heal spell
         */
        const CLERIC_HEAL = {
            name: 'Heal',
            type: 'heal',
            damageDice: '2d4+2',
            manaCost: 5,
        };

        /**
         * Mage magic attack
         */
        const MAGE_MAGIC_ATTACK = {
            name: 'Magic Missile',
            type: 'magic',
            damageDice: '1d4+1',
            manaCost: 3,
        };

        /**
         * Calculate ability modifier from score
         */
        function calculateModifier(score) {
            return Math.floor((score - 10) / 2);
        }

        /**
         * Roll dice using seeded RNG
         */
        function rollDice(rng, diceString) {
            const match = diceString.match(/(\d+)d(\d+)(?:\+(\d+))?/);
            if (!match) {
                throw new Error(`Invalid dice string: ${diceString}`);
            }

            const count = parseInt(match[1], 10);
            const sides = parseInt(match[2], 10);
            const modifier = match[3] ? parseInt(match[3], 10) : 0;
            const rolls = [];

            for (let i = 0; i < count; i++) {
                rolls.push(rng.range(1, sides));
            }

            return {
                total: rolls.reduce((sum, roll) => sum + roll, 0) + modifier,
                rolls: rolls,
            };
        }

        /**
         * Roll d20 using seeded RNG
         */
        function rollD20(rng) {
            return rng.range(1, 20);
        }

        /**
         * Resolve an attack
         */
        function resolveAttack(rng, attacker, target, weapon) {
            const attackRoll = rollD20(rng);
            const isCritical = attackRoll === 20;

            let attackStat = 10;
            if (weapon.type === 'melee-strength') {
                attackStat = attacker.strength || 10;
            } else if (weapon.type === 'melee-dexterity' || weapon.type === 'ranged') {
                attackStat = attacker.dexterity;
            }

            const attackModifier = calculateModifier(attackStat);
            const weaponModifier = weapon.attackModifier || 0;
            const attackTotal = attackRoll + attackModifier + weaponModifier;

            const hit = isCritical || attackTotal > target.ac;

            let damage = undefined;
            let damageRoll = undefined;

            if (hit) {
                const damageResult = rollDice(rng, weapon.damageDice);
                damageRoll = damageResult.rolls;

                const damageMod = weapon.damageModifier || 0;
                let statMod = 0;

                if (weapon.type === 'melee-strength') {
                    statMod = calculateModifier(attacker.strength || 10);
                } else if (weapon.type === 'melee-dexterity' || weapon.type === 'ranged') {
                    statMod = calculateModifier(attacker.dexterity);
                }

                damage = damageResult.total + statMod + damageMod;

                if (isCritical) {
                    const critResult = rollDice(rng, weapon.damageDice);
                    damage += critResult.total;
                    damageRoll = [...damageRoll, ...critResult.rolls];
                }
            }

            return {
                attackerId: attacker.id,
                targetId: target.id,
                hit: hit,
                attackRoll: attackRoll,
                attackTotal: attackTotal,
                targetAC: target.ac,
                damage: damage,
                damageRoll: damageRoll,
                criticalHit: isCritical,
            };
        }

        /**
         * Apply damage to an entity
         */
        function applyDamage(entity, damage) {
            const newHp = Math.max(0, entity.currentHp - damage);
            return {
                ...entity,
                currentHp: newHp,
            };
        }

        /**
         * Apply healing to an entity
         */
        function applyHealing(entity, healing) {
            const newHp = Math.min(entity.maxHp, entity.currentHp + healing);
            return {
                ...entity,
                currentHp: newHp,
            };
        }

        /**
         * Sort entities by dexterity for turn order
         */
        function determineTurnOrder(rng, entities) {
            const entityDex = entities.map(entity => ({
                id: entity.id,
                dexterity: entity.dexterity,
                random: rng.random(),
            }));

            entityDex.sort((a, b) => {
                if (b.dexterity !== a.dexterity) {
                    return b.dexterity - a.dexterity;
                }
                return b.random - a.random;
            });

            return entityDex.map(e => e.id);
        }

        /**
         * Get current entity in turn order
         */
        function getCurrentEntity(turnOrder, currentTurn) {
            return turnOrder[currentTurn] || null;
        }

        /**
         * Filter out dead entities from turn order
         */
        function filterAliveEntities(turnOrder, entities) {
            const aliveIds = new Set(
                entities.filter(e => e.currentHp > 0).map(e => e.id)
            );
            return turnOrder.filter(id => aliveIds.has(id));
        }

        /**
         * Create combat entity from adventurer
         */
        function createCombatEntityFromAdventurer(adventurer, id) {
            return {
                id: id || `party-${adventurer.heroId.tokenId}`,
                type: 'party',
                name: adventurer.name || `Hero ${adventurer.heroId.tokenId}`,
                dexterity: adventurer.stats.dexterity,
                currentHp: adventurer.stats.health,
                maxHp: adventurer.stats.maxHealth,
                ac: adventurer.stats.armorClass,
                strength: adventurer.stats.strength,
                mana: adventurer.stats.mana,
                maxMana: adventurer.stats.maxMana,
                class: adventurer.class,
                adventurerRecord: adventurer,
            };
        }

        /**
         * Create combat entity from monster
         */
        function createCombatEntityFromMonster(monster, id) {
            return {
                id: id || monster.id,
                type: 'monster',
                name: monster.statBlock.name,
                dexterity: monster.statBlock.dexterity,
                currentHp: monster.currentHp,
                maxHp: monster.maxHp,
                ac: monster.statBlock.ac,
                strength: monster.statBlock.strength,
                monsterInstance: monster,
            };
        }

        /**
         * Check combat status
         */
        function checkCombatStatus(state) {
            const aliveEntities = state.entities.filter(e => e.currentHp > 0);
            const partyAlive = aliveEntities.filter(e => e.type === 'party');
            const monstersAlive = aliveEntities.filter(e => e.type === 'monster');

            if (partyAlive.length === 0) {
                return 'defeat';
            }
            if (monstersAlive.length === 0) {
                return 'victory';
            }
            return 'active';
        }

        /**
         * Get weapon for an entity (default fallback)
         */
        function getEntityWeapon(entity) {
            return DEFAULT_WEAPONS[entity.class || 'warrior'];
        }

        /**
         * Determine action for an entity
         */
        function determineAction(rng, entity, entities, config) {
            const aliveEntities = entities.filter(e => e.currentHp > 0);
            const enemies = aliveEntities.filter(e => e.type !== entity.type);
            const allies = aliveEntities.filter(e => e.type === entity.type && e.id !== entity.id);

            if (enemies.length === 0) {
                return null;
            }

            if (entity.class === 'cleric') {
                const woundedAllies = allies.filter(a => a.currentHp < a.maxHp);
                const shouldHeal = woundedAllies.length > 0 && rng.random() < config.clericHealRatio;

                if (shouldHeal && entity.mana && entity.mana >= CLERIC_HEAL.manaCost) {
                    const target = woundedAllies.reduce((mostWounded, ally) =>
                        ally.currentHp < mostWounded.currentHp ? ally : mostWounded
                    );
                    return {
                        entityId: entity.id,
                        actionType: 'heal',
                        targetId: target.id,
                        weapon: CLERIC_HEAL,
                    };
                }
                const target = enemies[Math.floor(rng.random() * enemies.length)];
                const weapon = getEntityWeapon(entity);
                return {
                    entityId: entity.id,
                    actionType: 'attack',
                    targetId: target.id,
                    weapon: weapon,
                };
            }

            if (entity.class === 'mage') {
                const shouldUseMagic = entity.mana && entity.mana >= MAGE_MAGIC_ATTACK.manaCost &&
                    rng.random() < config.mageMagicRatio;

                if (shouldUseMagic) {
                    const target = enemies[Math.floor(rng.random() * enemies.length)];
                    return {
                        entityId: entity.id,
                        actionType: 'magic-attack',
                        targetId: target.id,
                        weapon: MAGE_MAGIC_ATTACK,
                    };
                }
                const target = enemies[Math.floor(rng.random() * enemies.length)];
                const weapon = getEntityWeapon(entity);
                return {
                    entityId: entity.id,
                    actionType: 'attack',
                    targetId: target.id,
                    weapon: weapon,
                };
            }

            const target = enemies[Math.floor(rng.random() * enemies.length)];
            const weapon = getEntityWeapon(entity);
            return {
                entityId: entity.id,
                actionType: 'attack',
                targetId: target.id,
                weapon: weapon,
            };
        }

        /**
         * Execute ambush round
         */
        function executeAmbushRound(rng, state, config) {
            if (!state.isAmbush || state.ambushCompleted) {
                return state;
            }

            let updatedState = { ...state, entities: [...state.entities] };
            const monsters = updatedState.entities.filter(e => e.type === 'monster' && e.currentHp > 0);
            const party = updatedState.entities.filter(e => e.type === 'party' && e.currentHp > 0);

            for (const monster of monsters) {
                if (party.length === 0) break;

                const target = party[Math.floor(rng.random() * party.length)];
                const weapon = {
                    name: 'Claw',
                    type: 'melee-strength',
                    damageDice: '1d6',
                    damageModifier: 0,
                    attackModifier: 0,
                };

                const attackResult = resolveAttack(rng, monster, target, weapon);

                if (attackResult.hit && attackResult.damage) {
                    const targetIndex = updatedState.entities.findIndex(e => e.id === target.id);
                    updatedState.entities[targetIndex] = applyDamage(
                        updatedState.entities[targetIndex],
                        attackResult.damage
                    );
                }

                updatedState.turns.push({
                    turnNumber: updatedState.turns.length + 1,
                    entityId: monster.id,
                    entityName: monster.name,
                    action: {
                        entityId: monster.id,
                        actionType: 'attack',
                        targetId: target.id,
                        weapon: weapon,
                    },
                    result: attackResult,
                });
            }

            updatedState.ambushCompleted = true;
            return updatedState;
        }

        /**
         * Execute a combat turn
         */
        function executeTurn(rng, state, config) {
            const aliveTurnOrder = filterAliveEntities(state.turnOrder, state.entities);

            if (aliveTurnOrder.length === 0) {
                return { state: state, result: null };
            }

            const currentEntityId = getCurrentEntity(aliveTurnOrder, state.currentTurn);
            if (!currentEntityId) {
                return { state: state, result: null };
            }

            const entity = state.entities.find(e => e.id === currentEntityId);
            if (!entity || entity.currentHp <= 0) {
                const nextState = {
                    ...state,
                    currentTurn: (state.currentTurn + 1) % aliveTurnOrder.length,
                };
                return { state: nextState, result: null };
            }

            const action = determineAction(rng, entity, state.entities, config);
            if (!action) {
                return { state: state, result: null };
            }

            let result;
            let updatedEntities = [...state.entities];
            const entityIndex = updatedEntities.findIndex(e => e.id === entity.id);
            let updatedEntity = { ...entity };

            if (action.actionType === 'heal') {
                const target = updatedEntities.find(e => e.id === action.targetId);
                if (!target || target.currentHp <= 0) {
                    const nextState = {
                        ...state,
                        currentTurn: (state.currentTurn + 1) % aliveTurnOrder.length,
                    };
                    return { state: nextState, result: null };
                }

                const healDice = rollDice(rng, action.weapon.damageDice);
                const healAmount = healDice.total;
                const healedTarget = applyHealing(target, healAmount);

                const manaCost = action.weapon.manaCost || 0;
                updatedEntity = {
                    ...updatedEntity,
                    mana: Math.max(0, (updatedEntity.mana || 0) - manaCost),
                };

                const targetIndex = updatedEntities.findIndex(e => e.id === target.id);
                updatedEntities[entityIndex] = updatedEntity;
                updatedEntities[targetIndex] = healedTarget;

                result = {
                    casterId: entity.id,
                    targetId: target.id,
                    amount: healAmount,
                    targetNewHp: healedTarget.currentHp,
                    targetMaxHp: healedTarget.maxHp,
                    manaCost: manaCost,
                    casterNewMana: updatedEntity.mana || 0,
                };
            } else if (action.actionType === 'magic-attack') {
                const target = updatedEntities.find(e => e.id === action.targetId);
                if (!target || target.currentHp <= 0) {
                    const nextState = {
                        ...state,
                        currentTurn: (state.currentTurn + 1) % aliveTurnOrder.length,
                    };
                    return { state: nextState, result: null };
                }

                const damageResult = rollDice(rng, action.weapon.damageDice);
                const damage = damageResult.total;
                const damagedTarget = applyDamage(target, damage);

                const manaCost = action.weapon.manaCost || 0;
                updatedEntity = {
                    ...updatedEntity,
                    mana: Math.max(0, (updatedEntity.mana || 0) - manaCost),
                };

                const targetIndex = updatedEntities.findIndex(e => e.id === target.id);
                updatedEntities[entityIndex] = updatedEntity;
                updatedEntities[targetIndex] = damagedTarget;

                result = {
                    attackerId: entity.id,
                    targetId: target.id,
                    hit: true,
                    attackRoll: 20,
                    attackTotal: 999,
                    targetAC: target.ac,
                    damage: damage,
                    damageRoll: damageResult.rolls,
                    criticalHit: false,
                };
            } else {
                const target = updatedEntities.find(e => e.id === action.targetId);
                if (!target || target.currentHp <= 0) {
                    const nextState = {
                        ...state,
                        currentTurn: (state.currentTurn + 1) % aliveTurnOrder.length,
                    };
                    return { state: nextState, result: null };
                }

                const attackResult = resolveAttack(rng, entity, target, action.weapon);
                result = attackResult;

                if (attackResult.hit && attackResult.damage) {
                    const damagedTarget = applyDamage(target, attackResult.damage);
                    const targetIndex = updatedEntities.findIndex(e => e.id === target.id);
                    updatedEntities[targetIndex] = damagedTarget;
                }
            }

            const nextTurn = (state.currentTurn + 1) % aliveTurnOrder.length;
            const updatedState = {
                ...state,
                entities: updatedEntities,
                currentTurn: nextTurn,
                turns: [
                    ...state.turns,
                    {
                        turnNumber: state.turns.length + 1,
                        entityId: entity.id,
                        entityName: entity.name,
                        action: action,
                        result: result,
                    },
                ],
            };

            return { state: updatedState, result: result };
        }

        /**
         * Initialize combat state
         */
        function initializeCombat(rng, partyMembers, monsters, roomId, isAmbush, config) {
            const partyEntities = partyMembers.map(a => createCombatEntityFromAdventurer(a));
            const monsterEntities = monsters.map(m => createCombatEntityFromMonster(m));
            const allEntities = [...partyEntities, ...monsterEntities];

            const turnOrder = determineTurnOrder(rng, allEntities);

            return {
                combatId: `combat-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                roomId: roomId,
                entities: allEntities,
                turnOrder: turnOrder,
                currentTurn: 0,
                turns: [],
                isAmbush: isAmbush,
                ambushCompleted: !isAmbush,
                status: 'active',
                startedAt: new Date(),
            };
        }

        /**
         * Run full combat until completion
         */
        function runCombat(rng, initialState, config) {
            let state = initialState;

            if (state.isAmbush && !state.ambushCompleted) {
                state = executeAmbushRound(rng, state, config);
            }

            const maxTurns = 1000;
            let turnCount = 0;

            while (state.status === 'active' && turnCount < maxTurns) {
                const { state: nextState } = executeTurn(rng, state, config);
                state = nextState;
                state.status = checkCombatStatus(state);
                turnCount++;

                if (state.status !== 'active') {
                    state.endedAt = new Date();
                    break;
                }
            }

            const partyAlive = state.entities.filter(e => e.type === 'party' && e.currentHp > 0);
            const monstersAlive = state.entities.filter(e => e.type === 'monster' && e.currentHp > 0);
            const partyTotal = state.entities.filter(e => e.type === 'party').length;
            const monstersTotal = state.entities.filter(e => e.type === 'monster').length;

            let xpAwarded = 0;
            if (state.status === 'victory') {
                const defeatedMonsters = state.entities.filter(
                    e => e.type === 'monster' && e.monsterInstance
                );
                xpAwarded = defeatedMonsters.reduce((sum, m) => {
                    return sum + (m.monsterInstance?.statBlock.xp || 0);
                }, 0);
            }

            const duration = state.endedAt
                ? state.endedAt.getTime() - state.startedAt.getTime()
                : Date.now() - state.startedAt.getTime();

            return {
                combatId: state.combatId,
                status: state.status,
                turns: state.turns,
                totalTurns: state.turns.length,
                partyMembersAlive: partyAlive.length,
                partyMembersTotal: partyTotal,
                monstersAlive: monstersAlive.length,
                monstersTotal: monstersTotal,
                xpAwarded: xpAwarded,
                duration: duration,
            };
        }

        /**
         * Parse encounter string to monster instances
         * Handles formats like "2x Skeleton", "Zombie", "3x Goblin"
         */
        function parseEncounterString(encounterString, seed, rng) {
            const match = encounterString.match(/(\d+)x?\s*(.+)/);
            let count = 1;
            let monsterName = encounterString.trim();

            if (match) {
                count = parseInt(match[1], 10);
                monsterName = match[2].trim();
            }

            const monsters = [];
            const monsterRegistryEntry = getMonsterByName(monsterName);
            
            if (!monsterRegistryEntry) {
                console.warn(`Monster "${monsterName}" not found in registry, using generic stats`);
                // Create a basic monster if not found
                const basicMonster = {
                    statBlock: createMonsterStatBlock(monsterName, 1, 20, 12, 13, 12, 10),
                };
                for (let i = 0; i < count; i++) {
                    monsters.push(createMonsterInstance(basicMonster.statBlock, `${monsterName}-${i}-${seed}`));
                }
            } else {
                for (let i = 0; i < count; i++) {
                    monsters.push(createMonsterInstance(monsterRegistryEntry.statBlock, `${monsterName}-${i}-${seed}`));
                }
            }

            return monsters;
        }

        /**
         * Create boss monster from bossInfo
         */
        function createBossMonster(bossInfo, dungeonLevel, seed) {
            // Try to find boss in registry first
            const bossRegistryEntry = getMonsterByName(bossInfo.bossName);
            
            if (bossRegistryEntry) {
                // Scale boss stats based on dungeon level if needed
                const statBlock = { ...bossRegistryEntry.statBlock };
                // For now, use base stats - can add scaling later
                return createMonsterInstance(statBlock, `boss-${bossInfo.bossId}-${seed}`);
            } else {
                // Create custom boss from bossInfo
                // Scale stats based on dungeon level
                const baseHP = 100 + (dungeonLevel * 10);
                const baseAC = 15 + Math.floor(dungeonLevel / 5);
                const baseSTR = 16 + Math.floor(dungeonLevel / 3);
                
                const statBlock = createMonsterStatBlock(
                    bossInfo.bossName,
                    Math.min(30, Math.floor(dungeonLevel / 5) + 5),
                    baseHP,
                    baseAC,
                    baseSTR,
                    14,
                    12
                );
                return createMonsterInstance(statBlock, `boss-${bossInfo.bossId}-${seed}`);
            }
        }

        /**
         * Run dungeon simulation
         */
        function runDungeonSimulation(partyMembers, dungeon, options) {
            const resultsEl = document.getElementById('combat-results');
            
            // Generate all rooms for the dungeon
            const world = sharedContext.world;
            const rooms = generateAllRoomsForDungeon(dungeon, world);
            
            // Create seeded RNG for deterministic combat
            const dungeonRNG = new SeededRNG(dungeon.seed || 'default');
            
            // Initialize dungeon run state - deep copy party members to track state
            let dungeonRunState = {
                currentLevel: 1,
                partyStatus: partyMembers.map(m => ({
                    heroId: { ...m.heroId },
                    walletAddress: m.walletAddress,
                    name: m.name,
                    class: m.class,
                    level: m.level,
                    experience: m.experience,
                    stats: {
                        health: m.stats.health,
                        maxHealth: m.stats.maxHealth,
                        mana: m.stats.mana || 0,
                        maxMana: m.stats.maxMana || 0,
                        strength: m.stats.strength,
                        dexterity: m.stats.dexterity,
                        wisdom: m.stats.wisdom,
                        intelligence: m.stats.intelligence,
                        constitution: m.stats.constitution,
                        charisma: m.stats.charisma,
                        perception: m.stats.perception,
                        armorClass: m.stats.armorClass,
                        attackBonus: m.stats.attackBonus,
                        spellAttackBonus: m.stats.spellAttackBonus,
                    },
                    createdAt: m.createdAt,
                    updatedAt: m.updatedAt,
                })),
                completedRooms: [],
                totalXP: 0,
                combatResults: [],
            };

            let html = '<div class="results-container">';
            html += `<h2 style="color: #ffd700; margin-bottom: 15px;">Dungeon Run: ${dungeon.name}</h2>`;
            html += `<div style="margin-bottom: 20px; color: #aaa;">Depth: ${dungeon.depth} levels | Party Size: ${partyMembers.length}</div>`;
            
            html += '<div style="margin-top: 20px; border-top: 2px solid #16213e; padding-top: 15px;">';
            html += '<h3 style="color: #ffd700; margin-bottom: 10px;">Room-by-Room Progress</h3>';
            
            // Process each room
            for (let i = 0; i < rooms.length; i++) {
                const room = rooms[i];
                const roomSeed = `${dungeon.seed}-combat-${room.level}`;
                const roomRNG = new SeededRNG(roomSeed);
                
                html += `<div style="margin-bottom: 15px; padding: 10px; background: #16213e; border-left: 4px solid ${room.type === 'boss' ? '#ff4444' : room.type === 'combat' ? '#ff8800' : room.type === 'safe' ? '#00ff00' : '#888888'}; border-radius: 4px;">`;
                html += `<div style="color: #ffd700; font-weight: bold; margin-bottom: 5px;">Level ${room.level}: ${room.name}</div>`;
                html += `<div style="color: #aaa; font-size: 0.9em; margin-bottom: 5px;">${room.type.charAt(0).toUpperCase() + room.type.slice(1)}${room.subtype ? ' (' + room.subtype.replace(/_/g, ' ') + ')' : ''}</div>`;
                
                if (room.type === 'combat' || (room.type === 'trap' && room.subtype === 'ambush')) {
                    // Handle combat encounter
                    const encounterSeed = `${roomSeed}-encounter`;
                    const encounterRNG = new SeededRNG(encounterSeed);
                    
                    // Parse encounters
                    const monsters = [];
                    if (room.encounters && room.encounters.length > 0) {
                        room.encounters.forEach(encounterStr => {
                            const parsed = parseEncounterString(encounterStr, encounterSeed, encounterRNG);
                            monsters.push(...parsed);
                        });
                    }
                    
                    if (monsters.length > 0) {
                        // Use current party state for combat (already has updated HP/mana)
                        const currentParty = dungeonRunState.partyStatus;
                        
                        const isAmbush = room.type === 'trap' && room.subtype === 'ambush';
                        
                        // Initialize combat
                        const combatState = initializeCombat(
                            encounterRNG,
                            currentParty,
                            monsters,
                            `room-${room.level}`,
                            isAmbush,
                            {
                                clericHealRatio: options.clericHealRatio,
                                mageMagicRatio: options.mageMagicRatio,
                            }
                        );
                        
                        // Run combat
                        const combatResult = runCombat(encounterRNG, combatState, {
                            clericHealRatio: options.clericHealRatio,
                            mageMagicRatio: options.mageMagicRatio,
                        });
                        
                        dungeonRunState.combatResults.push({
                            level: room.level,
                            roomType: room.type,
                            result: combatResult,
                        });
                        
                        if (combatResult.status === 'victory') {
                            dungeonRunState.totalXP += combatResult.xpAwarded || 0;
                            
                            // Update party HP/mana from combat entities
                            combatState.entities.filter(e => e.type === 'party').forEach(entity => {
                                const partyMember = dungeonRunState.partyStatus.find(p => 
                                    p.heroId.tokenId === entity.adventurerRecord.heroId.tokenId
                                );
                                if (partyMember) {
                                    partyMember.stats.health = Math.max(0, entity.currentHp);
                                    if (entity.mana !== undefined) {
                                        partyMember.stats.mana = Math.max(0, entity.mana);
                                    }
                                }
                            });
                            
                            html += `<div style="color: #00ff00; margin-top: 5px;">Γ£ô Victory! ${combatResult.totalTurns} turns, ${combatResult.xpAwarded || 0} XP</div>`;
                            
                            if (options.showDetails && !options.fastMode) {
                                html += `<div style="margin-top: 5px; font-size: 0.85em; color: #aaa;">`;
                                combatResult.turns.slice(0, 5).forEach(turn => {
                                    const entityName = turn.entityName;
                                    let actionText = '';
                                    if (turn.action.actionType === 'attack') {
                                        const attackResult = turn.result;
                                        actionText = attackResult.hit 
                                            ? `Hit for ${attackResult.damage} damage` 
                                            : 'Missed';
                                    } else if (turn.action.actionType === 'heal') {
                                        actionText = `Healed ${turn.result.amount} HP`;
                                    } else if (turn.action.actionType === 'magic-attack') {
                                        actionText = `Magic hit for ${turn.result.damage} damage`;
                                    }
                                    html += `<div>Turn ${turn.turnNumber}: ${entityName} - ${actionText}</div>`;
                                });
                                if (combatResult.turns.length > 5) {
                                    html += `<div>... and ${combatResult.turns.length - 5} more turns</div>`;
                                }
                                html += `</div>`;
                            }
                        } else {
                            html += `<div style="color: #ff4444; margin-top: 5px;">Γ£ù Defeat! Party was defeated.</div>`;
                            
                            if (options.showDetails && !options.fastMode) {
                                html += `<div style="margin-top: 5px; font-size: 0.85em; color: #aaa;">`;
                                combatResult.turns.slice(0, 5).forEach(turn => {
                                    const entityName = turn.entityName;
                                    let actionText = '';
                                    if (turn.action.actionType === 'attack') {
                                        const attackResult = turn.result;
                                        actionText = attackResult.hit 
                                            ? `Hit for ${attackResult.damage} damage` 
                                            : 'Missed';
                                    } else if (turn.action.actionType === 'heal') {
                                        actionText = `Healed ${turn.result.amount} HP`;
                                    } else if (turn.action.actionType === 'magic-attack') {
                                        actionText = `Magic hit for ${turn.result.damage} damage`;
                                    }
                                    html += `<div>Turn ${turn.turnNumber}: ${entityName} - ${actionText}</div>`;
                                });
                                if (combatResult.turns.length > 5) {
                                    html += `<div>... and ${combatResult.turns.length - 5} more turns</div>`;
                                }
                                html += `</div>`;
                            }
                            
                            if (options.stopOnDefeat) {
                                html += `<div style="color: #ff8800; margin-top: 10px; font-weight: bold;">Simulation stopped due to party defeat.</div>`;
                                html += `</div>`; // Close room div
                                break; // Stop simulation
                            }
                        }
                        
                        // Show party status after combat
                        const aliveCount = dungeonRunState.partyStatus.filter(p => p.stats.health > 0).length;
                        html += `<div style="color: #aaa; margin-top: 5px; font-size: 0.85em;">Party: ${aliveCount}/${dungeonRunState.partyStatus.length} alive</div>`;
                    }
                } else if (room.type === 'safe') {
                    // Safe room - restore HP/mana
                    dungeonRunState.partyStatus.forEach(member => {
                        member.stats.health = member.stats.maxHealth;
                        member.stats.mana = member.stats.maxMana;
                    });
                    html += `<div style="color: #00ff00; margin-top: 5px;">Γ£ô Safe room - Party rested (HP/mana restored)</div>`;
                } else if (room.type === 'boss') {
                    // Boss encounter
                    if (room.bossInfo) {
                        const bossSeed = `${roomSeed}-boss`;
                        const bossRNG = new SeededRNG(bossSeed);
                        const bossMonster = createBossMonster(room.bossInfo, room.level, bossSeed);
                        
                        const currentParty = dungeonRunState.partyStatus;
                        
                        const combatState = initializeCombat(
                            bossRNG,
                            currentParty,
                            [bossMonster],
                            `room-${room.level}-boss`,
                            false,
                            {
                                clericHealRatio: options.clericHealRatio,
                                mageMagicRatio: options.mageMagicRatio,
                            }
                        );
                        
                        const combatResult = runCombat(bossRNG, combatState, {
                            clericHealRatio: options.clericHealRatio,
                            mageMagicRatio: options.mageMagicRatio,
                        });
                        
                        dungeonRunState.combatResults.push({
                            level: room.level,
                            roomType: 'boss',
                            result: combatResult,
                        });
                        
                        if (combatResult.status === 'victory') {
                            dungeonRunState.totalXP += combatResult.xpAwarded || 0;
                            
                            combatState.entities.filter(e => e.type === 'party').forEach(entity => {
                                const partyMember = dungeonRunState.partyStatus.find(p => 
                                    p.heroId.tokenId === entity.adventurerRecord.heroId.tokenId
                                );
                                if (partyMember) {
                                    partyMember.stats.health = Math.max(0, entity.currentHp);
                                    if (entity.mana !== undefined) {
                                        partyMember.stats.mana = Math.max(0, entity.mana);
                                    }
                                }
                            });
                            
                            html += `<div style="color: #00ff00; margin-top: 5px; font-weight: bold;">Γ£ô BOSS DEFEATED! ${combatResult.totalTurns} turns, ${combatResult.xpAwarded || 0} XP</div>`;
                            
                            if (options.showDetails && !options.fastMode) {
                                html += `<div style="margin-top: 5px; font-size: 0.85em; color: #aaa;">`;
                                combatResult.turns.slice(0, 5).forEach(turn => {
                                    const entityName = turn.entityName;
                                    let actionText = '';
                                    if (turn.action.actionType === 'attack') {
                                        const attackResult = turn.result;
                                        actionText = attackResult.hit 
                                            ? `Hit for ${attackResult.damage} damage` 
                                            : 'Missed';
                                    } else if (turn.action.actionType === 'heal') {
                                        actionText = `Healed ${turn.result.amount} HP`;
                                    } else if (turn.action.actionType === 'magic-attack') {
                                        actionText = `Magic hit for ${turn.result.damage} damage`;
                                    }
                                    html += `<div>Turn ${turn.turnNumber}: ${entityName} - ${actionText}</div>`;
                                });
                                if (combatResult.turns.length > 5) {
                                    html += `<div>... and ${combatResult.turns.length - 5} more turns</div>`;
                                }
                                html += `</div>`;
                            }
                        } else {
                            html += `<div style="color: #ff4444; margin-top: 5px; font-weight: bold;">Γ£ù BOSS DEFEAT! Party was defeated by ${room.bossInfo.bossName}.</div>`;
                            
                            if (options.showDetails && !options.fastMode) {
                                html += `<div style="margin-top: 5px; font-size: 0.85em; color: #aaa;">`;
                                combatResult.turns.slice(0, 5).forEach(turn => {
                                    const entityName = turn.entityName;
                                    let actionText = '';
                                    if (turn.action.actionType === 'attack') {
                                        const attackResult = turn.result;
                                        actionText = attackResult.hit 
                                            ? `Hit for ${attackResult.damage} damage` 
                                            : 'Missed';
                                    } else if (turn.action.actionType === 'heal') {
                                        actionText = `Healed ${turn.result.amount} HP`;
                                    } else if (turn.action.actionType === 'magic-attack') {
                                        actionText = `Magic hit for ${turn.result.damage} damage`;
                                    }
                                    html += `<div>Turn ${turn.turnNumber}: ${entityName} - ${actionText}</div>`;
                                });
                                if (combatResult.turns.length > 5) {
                                    html += `<div>... and ${combatResult.turns.length - 5} more turns</div>`;
                                }
                                html += `</div>`;
                            }
                            
                            if (options.stopOnDefeat) {
                                html += `<div style="color: #ff8800; margin-top: 10px; font-weight: bold;">Simulation stopped due to party defeat.</div>`;
                                html += `</div>`;
                                break;
                            }
                        }
                        
                        const aliveCount = dungeonRunState.partyStatus.filter(p => p.stats.health > 0).length;
                        html += `<div style="color: #aaa; margin-top: 5px; font-size: 0.85em;">Party: ${aliveCount}/${dungeonRunState.partyStatus.length} alive</div>`;
                    }
                } else if (room.type === 'trap') {
                    // Trap room - simplified: skip or apply damage
                    html += `<div style="color: #ffaa00; margin-top: 5px;">ΓÜá Trap room - Skipped (simplified)</div>`;
                }
                
                dungeonRunState.completedRooms.push(room.level);
                html += `</div>`;
            }
            
            html += `</div>`; // Close room-by-room progress
            
            // Final summary
            html += '<div style="margin-top: 20px; border-top: 2px solid #16213e; padding-top: 15px;">';
            html += '<h3 style="color: #ffd700; margin-bottom: 10px;">Final Summary</h3>';
            html += `<div style="color: #aaa; margin-bottom: 5px;">Rooms Cleared: ${dungeonRunState.completedRooms.length}/${rooms.length}</div>`;
            html += `<div style="color: #aaa; margin-bottom: 5px;">Total XP Gained: ${dungeonRunState.totalXP}</div>`;
            
            const finalAliveCount = dungeonRunState.partyStatus.filter(p => p.stats.health > 0).length;
            const allAlive = finalAliveCount === dungeonRunState.partyStatus.length;
            
            if (allAlive && dungeonRunState.completedRooms.length === rooms.length) {
                html += `<div style="color: #00ff00; margin-top: 10px; font-weight: bold; font-size: 1.1em;">Γ£ô DUNGEON CLEARED! All party members survived.</div>`;
            } else if (finalAliveCount > 0) {
                html += `<div style="color: #ffaa00; margin-top: 10px; font-weight: bold;">Party Status: ${finalAliveCount}/${dungeonRunState.partyStatus.length} members alive</div>`;
            } else {
                html += `<div style="color: #ff4444; margin-top: 10px; font-weight: bold; font-size: 1.1em;">Γ£ù PARTY DEFEATED! All members fell in battle.</div>`;
            }
            
            html += '</div>'; // Close final summary
            html += '</div>'; // Close results-container
            
            resultsEl.innerHTML = html;
        }

        // Update dungeon select when world is generated
        const originalUpdateContextPanel = updateContextPanel;
        updateContextPanel = function() {
            originalUpdateContextPanel();
            updateCombatDungeonSelect();
            if (sharedContext.party) {
                updateCombatPartySelect();
            }
        };

        // Initialize
        console.log('Master Generation Tool initialized');
        console.log('This is a work in progress - systems will be ported from TypeScript contributions');
    </script>

    <!-- NOTE: The complete implementation will continue below with full ports of:
         1. World Generation System (all 9 levels)
         2. Map Generation System (with world integration)
         3. Themed Dungeon Generation System (with world+map integration)
         4. Item Generation System
         5. Integration layer functions
    -->
</body>
</html>